<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>使用select函数改进客户端/服务器端程序 | 大傻与小火机写字的地方</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="当我们使用单进程单连接且使用readline修改后的客户端程序，去连接使用readline修改后的服务器端程序。服务器主动close后，客户端和服务器会出现一个有趣的现象。
先运行服务器端，再运行客户端。建立连接后，服务器端有两个进程，一个父进程处于监听状态，另一子进程正在对客户端进行服务。kill掉服务器端的子进程。">
<meta property="og:type" content="article">
<meta property="og:title" content="使用select函数改进客户端/服务器端程序">
<meta property="og:url" content="https://murfyexp.github.io/2018/05/06/linux网络编程/使用select函数改进客户端:服务器端程序/index.html">
<meta property="og:site_name" content="大傻与小火机写字的地方">
<meta property="og:description" content="当我们使用单进程单连接且使用readline修改后的客户端程序，去连接使用readline修改后的服务器端程序。服务器主动close后，客户端和服务器会出现一个有趣的现象。
先运行服务器端，再运行客户端。建立连接后，服务器端有两个进程，一个父进程处于监听状态，另一子进程正在对客户端进行服务。kill掉服务器端的子进程。">
<meta property="og:updated_time" content="2018-05-31T02:43:15.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="使用select函数改进客户端/服务器端程序">
<meta name="twitter:description" content="当我们使用单进程单连接且使用readline修改后的客户端程序，去连接使用readline修改后的服务器端程序。服务器主动close后，客户端和服务器会出现一个有趣的现象。
先运行服务器端，再运行客户端。建立连接后，服务器端有两个进程，一个父进程处于监听状态，另一子进程正在对客户端进行服务。kill掉服务器端的子进程。">
  
    <link rel="alternate" href="/atom.xml" title="大傻与小火机写字的地方" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
  <link rel="stylesheet" href="/css/style.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  

</head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">大傻与小火机写字的地方</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Writing 1000 Words a Day Changes My Life</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://murfyexp.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-linux网络编程/使用select函数改进客户端:服务器端程序" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/06/linux网络编程/使用select函数改进客户端:服务器端程序/" class="article-date">
  <time datetime="2018-05-06T20:22:09.000Z" itemprop="datePublished">2018-05-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux网络编程/">Linux网络编程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      使用select函数改进客户端/服务器端程序
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>当我们使用单进程单连接且使用readline修改后的客户端程序，去连接使用readline修改后的服务器端程序。服务器主动close后，客户端和服务器会出现一个有趣的现象。</p>
<p>先运行服务器端，再运行客户端。建立连接后，服务器端有两个进程，一个父进程处于监听状态，另一子进程正在对客户端进行服务。kill掉服务器端的子进程。<br><a id="more"></a></p>
<h3 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h3><p>查看一下网络状态，发现客户端处于CLOSE_WAIT状态，服务器的状态为FIN_WAIT2。</p>
<pre><code>simba@ubuntu:~$ netstat -an | grep tcp | grep 5188
tcp        0      0 0.0.0.0:5188            0.0.0.0:*               LISTEN     
tcp        1      0 127.0.0.1:54005         127.0.0.1:5188          CLOSE_WAIT 
tcp        0      0 127.0.0.1:5188          127.0.0.1:54005         FIN_WAIT2
</code></pre><p>分析一下，将server子进程kill掉，则其终止时，socket描述符会自动关闭并发FIN段给client，<code>client收到FIN后处于CLOSE_WAIT状态，但是client并没有终止，也没有关闭socket描述符，因此不会发FIN段给server子进程，因此server子进程的TCP连接处于FIN_WAIT2状态。</code></p>
<p>为什么会出现这种情况呢，来看看client的部分程序：</p>
<pre><code class="lang-C">void do_echocli(int sock)
{

    char sendbuf[1024] = {0};
    char recvbuf[1024] = {0};

    while (fgets(sendbuf, sizeof(sendbuf), stdin) != NULL)
    {
        writen(sock, sendbuf, strlen(sendbuf));

        int ret = readline(sock, recvbuf, sizeof(recvbuf)); //按行读取
        if (ret == -1)
            ERR_EXIT(&quot;readline error&quot;);
        else if (ret  == 0)   //服务器关闭
        {
            printf(&quot;server close\n&quot;);
            break;
        }

        fputs(recvbuf, stdout);

        // 清空读写缓冲区
        memset(sendbuf, 0, sizeof(sendbuf));
        memset(recvbuf, 0, sizeof(recvbuf));
    }
    close(sock);
}
</code></pre>
<p>客户端程序阻塞在了fgets那里，即从标准输入读取数据，所以不能执行到下面的readline，也即不能返回0，不会退出循环，不会调用close关闭sock，所以出现上述的情况，即状态停滞，不能向前推进。</p>
<h3 id="select改进客户端"><a href="#select改进客户端" class="headerlink" title="select改进客户端"></a>select改进客户端</h3><p>出现上述问题的根本原因在于<code>客户端程序不能并发处理从标准输入读取数据和从套接字读取数据两个事件</code>，我们可以使用前面讲过的select函数来完善客户端程序。</p>
<pre><code class="lang-C">void do_echocli(int sock)
{
    fd_set rset;
    FD_ZERO(&amp;rset);

    int nready;
    int maxfd;
    int fd_stdin = fileno(stdin); //fileno用来取得参数stream指定的文件流所使用的文件描述符
    if (fd_stdin &gt; sock)
        maxfd = fd_stdin;
    else
        maxfd = sock;

    char sendbuf[1024] = {0};
    char recvbuf[1024] = {0};

    while (1)
    {

        FD_SET(fd_stdin, &amp;rset);
        FD_SET(sock, &amp;rset);
        nready = select(maxfd + 1, &amp;rset, NULL, NULL, NULL);                                   //select返回表示检测到可读事件
        if (nready == -1)
            ERR_EXIT(&quot;select error&quot;);

        if (nready == 0)
            continue;

        if (FD_ISSET(sock, &amp;rset))
        {
            int ret = readline(sock, recvbuf, sizeof(recvbuf)); //按行读取
            if (ret == -1)
                ERR_EXIT(&quot;read error&quot;);
            else if (ret  == 0)   //服务器关闭
            {
                printf(&quot;server close\n&quot;);
                break;
            }

            fputs(recvbuf, stdout);
            memset(recvbuf, 0, sizeof(recvbuf));
        }

        if (FD_ISSET(fd_stdin, &amp;rset))
        {
            if (fgets(sendbuf, sizeof(sendbuf), stdin) == NULL)
                break;

            writen(sock, sendbuf, strlen(sendbuf));
            memset(sendbuf, 0, sizeof(sendbuf));
        }
    }

    close(sock);
}
</code></pre>
<p>将两个事件都添加进可读事件集合，在while循环中，如果select返回说明有事件发生，依次判断是哪些事件发生，如果是标准输入有数据可读，则读取后再次回到循环开头select阻塞等待事件发生，如果是套接口有数据可读，且返回为0则说明对方已经关闭连接，退出循环并调用close关闭sock。</p>
<p>重复前面的实验过程，把客户端换成使用select函数修改后的程序，可以看到最后的输出。</p>
<pre><code>mur@ubuntu:~$ netstat -an | grep tcp | grep 5188
tcp        0      0 0.0.0.0:5188            0.0.0.0:*               LISTEN     
tcp        0      0 127.0.0.1:5188          127.0.0.1:54007         TIME_WAIT
</code></pre><p>client关闭socket描述符，server子进程的TCP连接<code>收到client发的FIN段后处于TIME_WAIT状态，</code>此时会再发生一个ACK段给client，client接收到之后就处于CLOSED状态。TCP协议规定，主动关闭连接的一方要处于TIME_WAIT状态，等待两个MSL（maximum segment lifetime）的时间后才能回到CLOSED状态，<code>需要有MSL时间的主要原因是在这段时间内如果最后一个ack段没有发送给对方，则可以重新发送。</code></p>
<h3 id="select改进服务端"><a href="#select改进服务端" class="headerlink" title="select改进服务端"></a>select改进服务端</h3><p>使用select函数来改进服务器端程序，实现单进程并发服务。</p>
<pre><code class="lang-C">#include&lt;stdio.h&gt;
#include&lt;sys/types.h&gt;
#include&lt;sys/socket.h&gt;
#include&lt;unistd.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;errno.h&gt;
#include&lt;arpa/inet.h&gt;
#include&lt;netinet/in.h&gt;
#include&lt;string.h&gt;
#include&lt;signal.h&gt;
#include&lt;sys/wait.h&gt;
#include &quot;read_write.h&quot;

#define ERR_EXIT(m) \
    do { \
        perror(m); \
        exit(EXIT_FAILURE); \
    } while (0)

int main(void)
{
    signal(SIGPIPE, SIG_IGN);
    int listenfd; //被动套接字(文件描述符），即只可以accept, 监听套接字
    if ((listenfd = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) &lt; 0)
//  listenfd = socket(AF_INET, SOCK_STREAM, 0)  
        ERR_EXIT(&quot;socket error&quot;);

    struct sockaddr_in servaddr;
    memset(&amp;servaddr, 0, sizeof(servaddr));
    servaddr.sin_family = AF_INET;
    servaddr.sin_port = htons(5188);
    servaddr.sin_addr.s_addr = htonl(INADDR_ANY); 
    /* servaddr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;); */
    /* inet_aton(&quot;127.0.0.1&quot;, &amp;servaddr.sin_addr); */

    int on = 1;
    if (setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;on, sizeof(on)) &lt; 0)
        ERR_EXIT(&quot;setsockopt error&quot;);

    if (bind(listenfd, (struct sockaddr*)&amp;servaddr,sizeof(servaddr)) &lt; 0)
        ERR_EXIT(&quot;bind error&quot;);

    if (listen(listenfd, SOMAXCONN) &lt; 0) //listen应在socket和bind之后，而在accept之前
        ERR_EXIT(&quot;listen error&quot;);

    struct sockaddr_in peeraddr; //传出参数
    socklen_t peerlen = sizeof(peeraddr); //传入传出参数，必须有初始值

    int conn; // 已连接套接字(变为主动套接字，即可以主动connect)
    int i;
    int client[FD_SETSIZE];
    int maxi = 0; // client数组中最大不空闲位置的下标
    for (i = 0; i &lt; FD_SETSIZE; i++)
        client[i] = -1;

    int nready;
    int maxfd = listenfd;
    fd_set rset;
    fd_set allset;
    FD_ZERO(&amp;rset);
    FD_ZERO(&amp;allset);
    FD_SET(listenfd, &amp;allset);

    while (1) {
        rset = allset;
        nready = select(maxfd + 1, &amp;rset, NULL, NULL, NULL);
        if (nready == -1) {
            if (errno == EINTR)
                continue;
            ERR_EXIT(&quot;select error&quot;);
        }

        if (nready == 0)
            continue;

        if (FD_ISSET(listenfd, &amp;rset)) {

            conn = accept(listenfd, (struct sockaddr*)&amp;peeraddr, &amp;peerlen);  //accept不再阻塞
            if (conn == -1)
                ERR_EXIT(&quot;accept error&quot;);

            for (i = 0; i &lt; FD_SETSIZE; i++) {
                if (client[i] &lt; 0) {
                    client[i] = conn;
                    if (i &gt; maxi)
                        maxi = i; //更新搜索范围
                    break;
                } 
            }

            if (i == FD_SETSIZE) {
                fprintf(stderr, &quot;too many clients\n&quot;);
                exit(EXIT_FAILURE);
            }

            printf(&quot;recv connect ip=%s port=%d\n&quot;, inet_ntoa(peeraddr.sin_addr),
                ntohs(peeraddr.sin_port));

            FD_SET(conn, &amp;allset);
            if (conn &gt; maxfd)
                maxfd = conn;

            if (--nready &lt;= 0)
                continue;
        }

        for (i = 0; i &lt;= maxi; i++) {
            conn = client[i];
            if (conn == -1)
                continue;

            if (FD_ISSET(conn, &amp;rset)) {
                char recvbuf[1024] = {0};
                int ret = readline(conn, recvbuf, 1024);
                if (ret == -1)
                    ERR_EXIT(&quot;readline error&quot;);
                else if (ret  == 0) { //客户端关闭 
                    printf(&quot;client close \n&quot;);
                    FD_CLR(conn, &amp;allset); // 踢出该端口
                    client[i] = -1;
                    close(conn);
                }

                fputs(recvbuf, stdout);
                writen(conn, recvbuf, strlen(recvbuf));

                if (--nready &lt;= 0)
                    break; 
            }
        }
    }

    return 0;
}
</code></pre>
<p>程序第一次进入while循环，只把监听套接字加入关心的事件，select返回说明监听套接字有可读事件，即已完成连接队列不为空，<code>这时调用accept不会阻塞，返回一个已连接套接字</code>，将这个套接字加入allset，因为<code>第一次运行则nready = 1，直接continue跳回到while循环开头，再次调用select</code>，这次会关心监听套接字和一个已连接套接字的可读事件，如果继续有客户端连接上来则继续将其加入allset，这次nready = 2，<code>继续执行下面的for循环，对客户端进行服务</code>。服务完毕再次回到while开头调用select阻塞，关心一个监听套接字和2个已连接套接字的可读事件了，一直循环下去。</p>
<p>client数组是用来保存已连接套接字的，为了避免每次都得遍历到FD_SETSIZE-1，<code>保存一个最大不空闲下标maxi</code>，每次遍历到maxi就可以了。每次得到一个conn，要判断一下conn与maxfd的大小。</p>
<p>当得知某个客户端<code>关闭</code>，则需要将conn在<code>allset中清除掉</code>。之所以要有allset和rset两个变量是因为rset是传入传出参数，在select返回时rset可能被改变，故需要<code>每次在回到while循环开头时需要将allset重新赋予rset。</code></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://murfyexp.github.io/2018/05/06/linux网络编程/使用select函数改进客户端:服务器端程序/" data-id="cjzbt3mdm000xz1xphlu07hnz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网络编程/">网络编程</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/05/06/linux网络编程/shutdown与close函数的区别/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          shutdown与close函数的区别
        
      </div>
    </a>
  
  
    <a href="/2018/05/05/linux网络编程/五种I:O模型和select函数简介/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">五种I/O模型和select函数简介</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C-C/">C/C++</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/DartNet网络协议栈/">DartNet网络协议栈</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JOS操作系统/">JOS操作系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux网络编程/">Linux网络编程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/miniftp服务器/">miniftp服务器</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/muduo网络库/">muduo网络库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/再学C/">再学C++</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数学/">数学</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构与算法/">数据结构与算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/模板与总结/">模板与总结</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法竞赛进阶指南/">算法竞赛进阶指南</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络编程/">网络编程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/老李的杂货铺/">老李的杂货铺</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/面试算法/">面试算法</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux系统编程和网络编程/">Linux系统编程和网络编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OS/">OS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/小技巧/">小技巧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/底层网络库/">底层网络库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/心得体会/">心得体会</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构-算法/">数据结构 算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构-算法-二分/">数据结构 算法 二分</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/概率论/">概率论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/线性代数/">线性代数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/编程语言/">编程语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络/">网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络编程/">网络编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/软件/">软件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/面试-算法/">面试 算法</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Linux系统编程和网络编程/" style="font-size: 10px;">Linux系统编程和网络编程</a> <a href="/tags/OS/" style="font-size: 12.5px;">OS</a> <a href="/tags/小技巧/" style="font-size: 10px;">小技巧</a> <a href="/tags/底层网络库/" style="font-size: 15px;">底层网络库</a> <a href="/tags/心得体会/" style="font-size: 10px;">心得体会</a> <a href="/tags/数据结构-算法/" style="font-size: 16.25px;">数据结构 算法</a> <a href="/tags/数据结构-算法-二分/" style="font-size: 10px;">数据结构 算法 二分</a> <a href="/tags/概率论/" style="font-size: 10px;">概率论</a> <a href="/tags/线性代数/" style="font-size: 10px;">线性代数</a> <a href="/tags/编程语言/" style="font-size: 18.75px;">编程语言</a> <a href="/tags/网络/" style="font-size: 13.75px;">网络</a> <a href="/tags/网络编程/" style="font-size: 17.5px;">网络编程</a> <a href="/tags/软件/" style="font-size: 11.25px;">软件</a> <a href="/tags/面试-算法/" style="font-size: 20px;">面试 算法</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/08/13/数学/极大似然估计的理解/">极大似然估计的理解</a>
          </li>
        
          <li>
            <a href="/2019/08/08/算法/算法竞赛进阶指南/分形之城/">分形之城</a>
          </li>
        
          <li>
            <a href="/2019/08/06/数学/矩阵旋转/">矩阵旋转</a>
          </li>
        
          <li>
            <a href="/2019/08/06/算法/算法竞赛进阶指南/递归求解等比数列求和/">递归求解等比数列求和</a>
          </li>
        
          <li>
            <a href="/2019/08/05/杂货铺/hexo的LaTeX渲染问题/">hexo的LaTeX渲染问题</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Shaojie Li<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>
</html>