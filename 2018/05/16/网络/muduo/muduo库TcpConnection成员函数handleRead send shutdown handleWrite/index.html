<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>muduo库TcpConnection成员函数handleRead send shutdown handleWrite | 大傻与小火机写字的地方</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="handleRead函数修改TcpConnection::handleRead()代码。现在当某个TcpConnection发生可读事件，调用TcpConnection::handleRead()，先调用inputBuffer.readFd()将内核接收缓冲区数据读取到inputBuffer中，接着调用messageCallback_，用户代码可以按消息界限从inputBuffer_ 中读取数据。">
<meta property="og:type" content="article">
<meta property="og:title" content="muduo库TcpConnection成员函数handleRead send shutdown handleWrite">
<meta property="og:url" content="https://murfyexp.github.io/2018/05/16/网络/muduo/muduo库TcpConnection成员函数handleRead send shutdown handleWrite/index.html">
<meta property="og:site_name" content="大傻与小火机写字的地方">
<meta property="og:description" content="handleRead函数修改TcpConnection::handleRead()代码。现在当某个TcpConnection发生可读事件，调用TcpConnection::handleRead()，先调用inputBuffer.readFd()将内核接收缓冲区数据读取到inputBuffer中，接着调用messageCallback_，用户代码可以按消息界限从inputBuffer_ 中读取数据。">
<meta property="og:updated_time" content="2018-06-13T14:40:04.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="muduo库TcpConnection成员函数handleRead send shutdown handleWrite">
<meta name="twitter:description" content="handleRead函数修改TcpConnection::handleRead()代码。现在当某个TcpConnection发生可读事件，调用TcpConnection::handleRead()，先调用inputBuffer.readFd()将内核接收缓冲区数据读取到inputBuffer中，接着调用messageCallback_，用户代码可以按消息界限从inputBuffer_ 中读取数据。">
  
    <link rel="alternate" href="/atom.xml" title="大傻与小火机写字的地方" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
  <link rel="stylesheet" href="/css/style.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  

</head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">大傻与小火机写字的地方</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://murfyexp.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-网络/muduo/muduo库TcpConnection成员函数handleRead send shutdown handleWrite" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/16/网络/muduo/muduo库TcpConnection成员函数handleRead send shutdown handleWrite/" class="article-date">
  <time datetime="2018-05-16T19:24:12.000Z" itemprop="datePublished">2018-05-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/muduo网络库/">muduo网络库</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      muduo库TcpConnection成员函数handleRead send shutdown handleWrite
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="handleRead函数"><a href="#handleRead函数" class="headerlink" title="handleRead函数"></a>handleRead函数</h3><p>修改TcpConnection::handleRead()代码。现在当某个TcpConnection发生可读事件，调用TcpConnection::handleRead()，先调用inputBuffer<em>.readFd()将内核接收缓冲区数据读取到inputBuffer</em>中，接着<code>调用messageCallback_，用户代码可以按消息界限从inputBuffer_ 中读取数据。</code><br><a id="more"></a></p>
<pre><code class="lang-C++">void TcpConnection::handleRead(Timestamp receiveTime)
{
    loop_-&gt;assertInLoopThread();
    int savedErrno = 0;
    ssize_t n = inputBuffer_.readFd(channel_-&gt;fd(), &amp;savedErrno);
    if (n &gt; 0)
    {
        messageCallback_(shared_from_this(), &amp;inputBuffer_, receiveTime);
    }
    else if (n == 0)
    {
        handleClose();
    }
    else
    {
        errno = savedErrno;
        LOG_SYSERR &lt;&lt; &quot;TcpConnection::handleRead&quot;;
        handleError();
    }
}
</code></pre>
<h3 id="send函数"><a href="#send函数" class="headerlink" title="send函数"></a>send函数</h3><p>用户代码想要发送数据时，调用TcpConnection::send()，重载了3个版本，都是线程安全的，内部最终都是调用TcpConnection::sendInLoop()。<code>如果不是在当前IO线程调用send时，sendInLoop会在当前IO线程处理doPendingFunctors时被调用。</code></p>
<p>首先尝试write入内核发送缓冲区，如果内核发送缓冲区满则将未写完的数据添加到outputBuffer<em>中。`只要第一次没写完，下次调用send也会将数据添加到outputBuffer</em>的末尾而不直接write，并关注POLLOUT 事件，当内核发送缓冲区不为满，即发生可写事件，调用TcpConnection::handleWrite() `。</p>
<pre><code class="lang-C++">void TcpConnection::sendInLoop(const void *data, size_t len)
{
    loop_-&gt;assertInLoopThread();
    ssize_t nwrote = 0;
    size_t remaining = len;
    bool error = false;
    if (state_ == kDisconnected)
    {
        LOG_WARN &lt;&lt; &quot;disconnected, give up writing&quot;;
        return;
    }
    // if no thing in output queue, try writing directly
    // 通道没有关注可写事件并且应用层发送缓冲区没有数据，直接write
    if (!channel_-&gt;isWriting() &amp;&amp; outputBuffer_.readableBytes() == 0)
    {
        nwrote = sockets::write(channel_-&gt;fd(), data, len);
        if (nwrote &gt;= 0)
        {
            remaining = len - nwrote;
            // 写完了，回调writeCompleteCallback_
            if (remaining == 0 &amp;&amp; writeCompleteCallback_)
            {
                loop_-&gt;queueInLoop(boost::bind(writeCompleteCallback_, shared_from_this()));
            }
        }
        else // nwrote &lt; 0
        {
            nwrote = 0;
            if (errno != EWOULDBLOCK)
            {
                LOG_SYSERR &lt;&lt; &quot;TcpConnection::sendInLoop&quot;;
                if (errno == EPIPE) // FIXME: any others?
                {
                    error = true;
                }
            }
        }
    }

    assert(remaining &lt;= len);
    // 没有错误，并且还有未写完的数据（说明内核发送缓冲区满，要将未写完的数据添加到output buffer中）
    if (!error &amp;&amp; remaining &gt; 0)
    {
        LOG_TRACE &lt;&lt; &quot;I am going to write more data&quot;;
        size_t oldLen = outputBuffer_.readableBytes();
        // 如果超过highWaterMark_（高水位标），回调highWaterMarkCallback_
        if (oldLen + remaining &gt;= highWaterMark_
                &amp;&amp; oldLen &lt; highWaterMark_
                &amp;&amp; highWaterMarkCallback_)
        {
            loop_-&gt;queueInLoop(boost::bind(highWaterMarkCallback_, shared_from_this(), oldLen + remaining));
        }
        outputBuffer_.append(static_cast&lt;const char *&gt;(data) + nwrote, remaining);
        if (!channel_-&gt;isWriting())
        {
            channel_-&gt;enableWriting();      // 关注POLLOUT事件
        }
    }
}
</code></pre>
<h3 id="handleWrite函数"><a href="#handleWrite函数" class="headerlink" title="handleWrite函数"></a>handleWrite函数</h3><p>从outputBuffer_中取出数据写入内核发送缓冲区，当然也许此次并不能完全写入，<code>但只要应用层发送缓冲区不为空，就一直关注POLLOUT事件，当内核发送缓冲区不满时触发再次写入。</code></p>
<pre><code class="lang-C++">// 内核发送缓冲区有空间了，回调该函数
void TcpConnection::handleWrite()
{
    loop_-&gt;assertInLoopThread();
    if (channel_-&gt;isWriting())
    {
        ssize_t n = sockets::write(channel_-&gt;fd(),
                                   outputBuffer_.peek(),
                                   outputBuffer_.readableBytes());
        if (n &gt; 0)
        {
            outputBuffer_.retrieve(n);
            if (outputBuffer_.readableBytes() == 0)  // 应用层发送缓冲区已清空
            {
                channel_-&gt;disableWriting();     // 停止关注POLLOUT事件，以免出现busy loop
                if (writeCompleteCallback_)     // 回调writeCompleteCallback_
                {
                    // 应用层发送缓冲区被清空，就回调用writeCompleteCallback_
                    loop_-&gt;queueInLoop(boost::bind(writeCompleteCallback_, shared_from_this()));
                }
                if (state_ == kDisconnecting)   // 应用层发送缓冲区已清空并且连接状态是kDisconnecting, 要关闭连接
                {
                    shutdownInLoop();       // 关闭连接
                }
            }
            else
            {
                LOG_TRACE &lt;&lt; &quot;I am going to write more data&quot;;
            }
        }
        else
        {
            LOG_SYSERR &lt;&lt; &quot;TcpConnection::handleWrite&quot;;
            // if (state_ == kDisconnecting)
            // {
            //   shutdownInLoop();
            // }
        }
    }
    else
    {
        LOG_TRACE &lt;&lt; &quot;Connection fd = &quot; &lt;&lt; channel_-&gt;fd()
                  &lt;&lt; &quot; is down, no more writing&quot;;
    }
}
</code></pre>
<h3 id="shutdown函数"><a href="#shutdown函数" class="headerlink" title="shutdown函数"></a>shutdown函数</h3><p>shutdown是线程安全地，shutdownInloop保证在IO线程中调用。send函数也是一样。<code>如果在非IO线程调用，它会把message复制一份，传给IO线程的sendInLoop来发送。</code></p>
<p>如果output buffer里还有待发送的数据，而程序又想关闭连接。对程序而言，调用TcpConnection::send()之后他就认为数据迟早会发出去，<code>那么这时候网络库不能立刻关闭连接，而要等数据发送完毕</code>，Muduo TcpConnection没有提供close，而只<code>提供shutdown，这么做是为了收发数据的完整性。</code>用shutdown而不用close的效果是，如果对方已经发送了数据，这些数据还“在路上”，那么muduo不会漏收这些数据。</p>
<p>如果应用层缓冲区数据还没发完，即还在关注POLLOUT事件，那么<code>shutdown()中只是先设置state_ = kDisconnecting；shutdownInLoop()中判断isWriting()为true，故不会执行shutdownWrite()</code>，handleWrite()函数，当应用层缓冲区数据发完，<code>判断状态为kDisconnecting而且已经disableWriting()，就调用shutdownInLoop() ，此时就会真正关闭写的这一端。</code></p>
<p>我们发完了数据，于是shutdownWrite，发送TCP FIN分节。对方会读到0字节，然后关闭连接，可读事件发生调用handleRead()，调用handleClose()，进而 <code>调用connectionCallback_，这样客户代码就知道对方断开连接了（判断是否connected()）</code>，最后调用closeCallback_（TcpServer::removeConnection()）。</p>
<pre><code class="lang-C++">void DaytimeServer::onConnection(const muduo::net::TcpConnectionPtr &amp;conn)
{
    if (conn-&gt;connected())
    {
        conn-&gt;send(Timestamp::now().toFormattedString() + ”\n”);
        conn-&gt;shutdown(); // 调用TcpConnection::shutdown()
    }
}

void TcpConnection::shutdown()
{
    if (state_ == kConnected)
    {
        setState(kDisconnecting);
        // 调用TcpConnection::shutdownInLoop()
        loop_-&gt;runInLoop(boost::bind(&amp;TcpConnection::shutdownInLoop, this));
    }
}

void TcpConnection::shutdownInLoop()
{
    loop_-&gt;assertInLoopThread();
    if (!channel_-&gt;isWriting())
    {
        // we are not writing
        socket_-&gt;shutdownWrite(); // 调用Socket::shutdownWrite()
    }
}

void Socket::shutdownWrite()
{
    sockets::shutdownWrite(sockfd_);
}

void sockets::shutdownWrite(int sockfd)
{
    int ret = ::shutdown(sockfd, SHUT_WR);
    // 检查错误
}
</code></pre>
<p>那么muduo什么时候真正close socket 呢？<code>在TcpConnection对象析构的时候。TcpConnection持有一个Socket对象，Socket是一个RAII handler，它的析构函数会close(sockfd_)。</code></p>
<h3 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h3><pre><code class="lang-C++">#include &lt;muduo/net/TcpServer.h&gt;
#include &lt;muduo/net/EventLoop.h&gt;
#include &lt;muduo/net/InetAddress.h&gt;

#include &lt;boost/bind.hpp&gt;

#include &lt;stdio.h&gt;

using namespace muduo;
using namespace muduo::net;

class TestServer
{
public:
    TestServer(EventLoop *loop,
               const InetAddress &amp;listenAddr)
        : loop_(loop),
          server_(loop, listenAddr, &quot;TestServer&quot;)
    {
        server_.setConnectionCallback(
            boost::bind(&amp;TestServer::onConnection, this, _1));
        server_.setMessageCallback(
            boost::bind(&amp;TestServer::onMessage, this, _1, _2, _3));

        message1_.resize(100);
        message2_.resize(200);
        std::fill(message1_.begin(), message1_.end(), &#39;A&#39;);
        std::fill(message2_.begin(), message2_.end(), &#39;B&#39;);
    }

    void start()
    {
        server_.start();
    }

private:
    void onConnection(const TcpConnectionPtr &amp;conn)
    {
        if (conn-&gt;connected())
        {
            printf(&quot;onConnection(): new connection [%s] from %s\n&quot;,
                   conn-&gt;name().c_str(),
                   conn-&gt;peerAddress().toIpPort().c_str());
            conn-&gt;send(message1_);
            conn-&gt;send(message2_);
            conn-&gt;shutdown();
        }
        else
        {
            printf(&quot;onConnection(): connection [%s] is down\n&quot;,
                   conn-&gt;name().c_str());
        }
    }

    void onMessage(const TcpConnectionPtr &amp;conn,
                   Buffer *buf,
                   Timestamp receiveTime)
    {
        muduo::string msg(buf-&gt;retrieveAllAsString());
        printf(&quot;onMessage(): received %zd bytes from connection [%s] at %s\n&quot;,
               msg.size(),
               conn-&gt;name().c_str(),
               receiveTime.toFormattedString().c_str());

        conn-&gt;send(msg);
    }

    EventLoop *loop_;
    TcpServer server_;

    muduo::string message1_;
    muduo::string message2_;
};


int main()
{
    printf(&quot;main(): pid = %d\n&quot;, getpid());

    InetAddress listenAddr(8888);
    EventLoop loop;

    TestServer server(&amp;loop, listenAddr);
    server.start();

    loop.loop();
}
</code></pre>
<p>程序中一旦连接建立，调用onConnection()，send(message1),send(message2)，然后立马shutdown()。由前面分析可知会一直等到outputBuffer_数据全部写到内核发送缓冲区才会真正关闭写端，客户端读到数据后最后read返回0，客户端close导致服务端最终removeConnection。可以看到<code>在handleEvent()处理完毕后TcpConnection才会析构。</code></p>
<h3 id="WriteCompleteCallback-highWaterMarkCallback"><a href="#WriteCompleteCallback-highWaterMarkCallback" class="headerlink" title="WriteCompleteCallback/highWaterMarkCallback"></a>WriteCompleteCallback<em>/highWaterMarkCallback</em></h3><p>如果我们向一个连接发送send()大流量的数据，发送频率不能太快，因为如果对等方接收不及时，则内核发送缓冲区会堆积数据，根据前面的分析，我们会将数据添加到outputBuffer<em>，导致outputBuffer</em>增长太快。<code>对此可以关注WriteCompleteCallback_，当它被调用时表示outputBuffer_已经被清空，此时再次send()，否则outputBuffer_ 可能一直增长直到撑爆。</code></p>
<p>可以把WriteCompleteCallback<em>当作是“低水位标”回调函数，highWaterMarkCallback</em>当作是”高水位标“回调函数，即如果对等方接收不及时，outputBuffer<em>会一直增大，`当增长到highWaterMark</em>（具体数值）时，回调highWaterMarkCallback_函数，很可能在函数内主动shutdown。`</p>
<p><code>TcpClient和TcpServer需要相应地暴露writeCompleteCallback_接口。</code>如果输出缓冲的长度超过用户指定的大小，就会触发回调highWaterMarkCallback_。</p>
<p>下面的程序会不断地发送不同的字符数据，类似chargen协议（DDos）</p>
<pre><code class="lang-C++">#include &lt;muduo/net/TcpServer.h&gt;
#include &lt;muduo/net/EventLoop.h&gt;
#include &lt;muduo/net/InetAddress.h&gt;

#include &lt;boost/bind.hpp&gt;

#include &lt;stdio.h&gt;

using namespace muduo;
using namespace muduo::net;

class TestServer
{
public:
    TestServer(EventLoop *loop,
               const InetAddress &amp;listenAddr)
        : loop_(loop),
          server_(loop, listenAddr, &quot;TestServer&quot;)
    {
        server_.setConnectionCallback(
            boost::bind(&amp;TestServer::onConnection, this, _1));
        server_.setMessageCallback(
            boost::bind(&amp;TestServer::onMessage, this, _1, _2, _3));
        server_.setWriteCompleteCallback(
            boost::bind(&amp;TestServer::onWriteComplete, this, _1));

        // 生成数据
        string line;
        for (int i = 33; i &lt; 127; ++i)
        {
            line.push_back(char(i));
        }
        line += line;

        for (size_t i = 0; i &lt; 127 - 33; ++i)
        {
            message_ += line.substr(i, 72) + &#39;\n&#39;;
        }
    }

    void start()
    {
        server_.start();
    }

private:
    void onConnection(const TcpConnectionPtr &amp;conn)
    {
        if (conn-&gt;connected())
        {
            printf(&quot;onConnection(): new connection [%s] from %s\n&quot;,
                   conn-&gt;name().c_str(),
                   conn-&gt;peerAddress().toIpPort().c_str());

            conn-&gt;setTcpNoDelay(true);
            conn-&gt;send(message_);
        }
        else
        {
            printf(&quot;onConnection(): connection [%s] is down\n&quot;,
                   conn-&gt;name().c_str());
        }
    }

    void onMessage(const TcpConnectionPtr &amp;conn,
                   Buffer *buf,
                   Timestamp receiveTime)
    {
        muduo::string msg(buf-&gt;retrieveAllAsString());
        printf(&quot;onMessage(): received %zd bytes from connection [%s] at %s\n&quot;,
               msg.size(),
               conn-&gt;name().c_stC                                r(),
               receiveTime.toFormattedString().c_str());

        conn-&gt;send(msg);
    }

    void onWriteComplete(const TcpConnectionPtr &amp;conn)
    {
        conn-&gt;send(message_);
    }

    EventLoop *loop_;
    TcpServer server_;

    muduo::string message_;
};

int main()
{
    printf(&quot;main(): pid = %d\n&quot;, getpid());

    InetAddress listenAddr(8888);
    EventLoop loop;

    TestServer server(&amp;loop, listenAddr);
    server.start();

    loop.loop();
}
</code></pre>
<p>程序中一旦连接建立就开始send，当outputBuffer_数据全部拷贝到内核发送缓冲区后，<code>回调OnWriteComplete()， 继续send，类似大流量的ddos攻击。</code></p>
<h3 id="boost-any"><a href="#boost-any" class="headerlink" title="boost::any"></a>boost::any</h3><pre><code class="lang-C++">TcpConnection中boost::any context_;  // 绑定一个未知类型的上下文对象比如HttpContext
</code></pre>
<p>可变类型解决方案：<code>void*</code>这种方法不是类型安全的。boost::any任意类型的类型安全存储以及安全的取回。在标准库容器中存放不同类型的方法，比如说<code>vector&lt;boost::any&gt;</code></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://murfyexp.github.io/2018/05/16/网络/muduo/muduo库TcpConnection成员函数handleRead send shutdown handleWrite/" data-id="cjzbvs4q6007t9txpi7nbbg45" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/底层网络库/">底层网络库</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/05/16/算法/Leetcode/实现strStr()/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          实现strStr()
        
      </div>
    </a>
  
  
    <a href="/2018/05/15/算法/Leetcode/两数相加和II/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">两数相加和II(已排序数组)</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Linux系统编程和网络编程/" style="font-size: 10px;">Linux系统编程和网络编程</a> <a href="/tags/OS/" style="font-size: 12.5px;">OS</a> <a href="/tags/小技巧/" style="font-size: 10px;">小技巧</a> <a href="/tags/底层网络库/" style="font-size: 15px;">底层网络库</a> <a href="/tags/心得体会/" style="font-size: 10px;">心得体会</a> <a href="/tags/数据结构-算法/" style="font-size: 16.25px;">数据结构 算法</a> <a href="/tags/数据结构-算法-二分/" style="font-size: 10px;">数据结构 算法 二分</a> <a href="/tags/概率论/" style="font-size: 10px;">概率论</a> <a href="/tags/线性代数/" style="font-size: 10px;">线性代数</a> <a href="/tags/编程语言/" style="font-size: 18.75px;">编程语言</a> <a href="/tags/网络/" style="font-size: 13.75px;">网络</a> <a href="/tags/网络编程/" style="font-size: 17.5px;">网络编程</a> <a href="/tags/软件/" style="font-size: 11.25px;">软件</a> <a href="/tags/面试-算法/" style="font-size: 20px;">面试 算法</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/08/13/数学/极大似然估计的理解/">极大似然估计的理解</a>
          </li>
        
          <li>
            <a href="/2019/08/08/算法/算法竞赛进阶指南/分形之城/">分形之城</a>
          </li>
        
          <li>
            <a href="/2019/08/06/数学/矩阵旋转/">矩阵旋转</a>
          </li>
        
          <li>
            <a href="/2019/08/06/算法/算法竞赛进阶指南/递归求解等比数列求和/">递归求解等比数列求和</a>
          </li>
        
          <li>
            <a href="/2019/08/05/杂货铺/hexo的LaTeX渲染问题/">hexo的LaTeX渲染问题</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Shaojie Li<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>