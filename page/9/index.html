<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="大傻与小火机写字的地方" type="application/atom+xml" />






<meta name="description" content="学习总结 思考感悟 知识管理">
<meta property="og:type" content="website">
<meta property="og:title" content="大傻与小火机写字的地方">
<meta property="og:url" content="https://murfyexp.github.io/page/9/index.html">
<meta property="og:site_name" content="大傻与小火机写字的地方">
<meta property="og:description" content="学习总结 思考感悟 知识管理">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="大傻与小火机写字的地方">
<meta name="twitter:description" content="学习总结 思考感悟 知识管理">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://murfyexp.github.io/page/9/"/>





  <title>大傻与小火机写字的地方</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">大傻与小火机写字的地方</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Writing 1000 Words a Day Changes My Life</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://murfyexp.github.io/2017/03/14/linux网络编程/TCP协议产生的粘包问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shaojie Li">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://pic2.zhimg.com/85f345ee7c2ac6bf572a9a41895a4be5_200x112.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大傻与小火机写字的地方">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/14/linux网络编程/TCP协议产生的粘包问题/" itemprop="url">TCP协议产生的粘包问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-14T21:06:40-07:00">
                2017-03-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux网络编程/" itemprop="url" rel="index">
                    <span itemprop="name">Linux网络编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/14/linux网络编程/TCP协议产生的粘包问题/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/14/linux网络编程/TCP协议产生的粘包问题/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="粘包"><a href="#粘包" class="headerlink" title="粘包"></a>粘包</h3><p>所谓的粘包问题主要是因为<code>接收方不知道消息之间的界限，不知道一次性提取多少字节的数据</code>所造成的。发送方引起的粘包<code>跟TCP协议本身有关</code>，TCP为提高传输效率，发送方往往要<code>收集到足够多的数据后才发送一个TCP段</code>，这样接收方就收到了粘包数据。而UDP是面向消息的协议，<code>每个UDP段都是一条消息</code>，应用程序必须以消息为单位提取数据，不能一次提取任意字节的数据。</p>
<h4 id="粘包问题的解决方案"><a href="#粘包问题的解决方案" class="headerlink" title="粘包问题的解决方案"></a>粘包问题的解决方案</h4><p>从本质上解决，<code>在应用层维护消息与消息的边界</code></p>
<ul>
<li>更复杂的应用层协议</li>
<li>用一个包体中绝不会出现的结束标志标识包结束</li>
<li>告知包的长度协议头开始固定长度的字节告知后续包长。收方先收包长字节，知道了后续包长后再收 </li>
</ul>
<p>方法三实现<br>我们自定义一个包体结构。<code>先接收固定的4个字节，从中得知实际数据的长度n，再调用readn读取n个字符</code>，这样数据包之间有了界定。</p>
<pre><code class="lang-C">struct packet {
    int len;
    char buf[1024];
};

void do_service(int conn)
{
    struct packet recvbuf;
    int n;
    while (1)
    {
        memset(&amp;recvbuf, 0, sizeof(recvbuf));
        int ret = readn(conn, &amp;recvbuf.len, 4);
        if (ret == -1)
            ERR_EXIT(&quot;read error&quot;);
        else if (ret &lt; 4)   //客户端关闭
        {
            printf(&quot;client close\n&quot;);
            break;
        }

        n = ntohl(recvbuf.len);
        ret = readn(conn, recvbuf.buf, n);
        if (ret == -1)
            ERR_EXIT(&quot;read error&quot;);
        if (ret &lt; n)   //客户端关闭
        {
            printf(&quot;client close\n&quot;);
            break;
        }

        fputs(recvbuf.buf, stdout);
        writen(conn, &amp;recvbuf, 4 + n);
    }
}
</code></pre>
<h3 id="拆包"><a href="#拆包" class="headerlink" title="拆包"></a>拆包</h3><p>既然TCP传输容易出现粘包，<code>并且在很多应用中，消息必须使用固定的格式发送。在这种情况下，我们需要拆包，按发送格式解析数据流</code>。大二参加华为精英挑战赛，德州扑克AI。服务器发送过来的数据流就出现了粘包问题。下面简单地介绍拆包的两种方法。</p>
<h4 id="动态缓冲区暂存"><a href="#动态缓冲区暂存" class="headerlink" title="动态缓冲区暂存"></a>动态缓冲区暂存</h4><p><code>每一个连接动态分配一个缓冲区，同时把此缓冲区和SOCKET关联</code>。当接收到数据时首先把此段数据存放在缓冲区中。判断缓冲区中数据长度是否够一个包头的长度，如不够，不进行拆包操作。<code>根据包头解析出包体长度</code>。判断缓存区中除包头外的数据长度是否够一个包体的长度，如不够，不进行拆包操作。<code>取出整个数据包</code>。不仅从缓冲区中拷贝出数据包，而且要把此数据包从缓存区中删除掉。<code>把此包后面的数据移动到缓冲区的起始地址</code>。</p>
<p><code>空间上的消耗</code>：为每个连接动态分配一个缓冲区需要使用大量的内存<br><code>时间上的消耗</code>：<code>三个地方需要拷贝数据</code>，把数据存放在缓冲区，把完整的数据包从缓冲区取出来，把数据包从缓冲区中删除。</p>
<h4 id="动态缓冲区暂存的优化"><a href="#动态缓冲区暂存的优化" class="headerlink" title="动态缓冲区暂存的优化"></a>动态缓冲区暂存的优化</h4><p><code>TCP协议本身维护了一个缓冲区</code>，所以我们可以直接利用TCP的缓冲区来缓存我们的数据，不需要为每一个连接分配一个缓冲区了。<code>recv或者wsarecv都有一个参数，用来表示我们要接收多长的数据</code>。每次根据得到的长度从缓冲区读取相应的数据字节即可。</p>
<p>参考链接<br><a href="http://al1020119.github.io/blog/2015/12/09/nian-bao-and-feng-bao-and-chai-bao/" target="_blank" rel="external">粘包与拆包</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://murfyexp.github.io/2017/03/14/网络/DartNet/三次握手与四次挥手/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shaojie Li">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://pic2.zhimg.com/85f345ee7c2ac6bf572a9a41895a4be5_200x112.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大傻与小火机写字的地方">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/14/网络/DartNet/三次握手与四次挥手/" itemprop="url">三次握手与四次挥手</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-14T15:28:32-07:00">
                2017-03-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/网络编程/" itemprop="url" rel="index">
                    <span itemprop="name">网络编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/14/网络/DartNet/三次握手与四次挥手/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/14/网络/DartNet/三次握手与四次挥手/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>TCP和UDP的区别</p>
<blockquote>
<ul>
<li>TCP提供<code>面向连接的、可靠的数据流</code>传输</li>
<li>UDP提供<code>非面向连接的、不可靠的数据报</code>传输</li>
<li>TCP数据<code>安全可靠</code>，UDP数据<code>传输快</code></li>
</ul>
</blockquote>
<h3 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h3><p>主机A向B发送连接请求<br>主机B对收到的主机A的报文段进行确认<br>主机A再次对主机B的确认进行确认</p>
<p>三次握手状态图(第二次ack应为x+1)<br><img src="/images/三次握手.png" alt=""></p>
<p>TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗?<br>采用三次握手是为了<code>防止失效的连接请求报文段突然又传送到主机</code>，因而产生错误</p>
<p>考虑这样一种特殊情况，主机A第一次发送的<code>连接请求</code>并没有丢失，而是<code>因为网络节点导致延迟达到主机B</code>。主机B以为是主机A又发起的新连接，于是主机B同意连接，并向主机A发回确认，<code>此时主机A根本不会理会</code>，主机B就一直在<code>等待主机A发送数据，导致主机B的资源浪费</code></p>
<p>如果采用<code>三次握手</code>，由于客户端不会向服务端发出确认，<code>服务端由于没有收到确认信息</code>，就知道客户端没有要求建立连接，<code>不建立该连接</code></p>
<h4 id="SYN-flood攻击"><a href="#SYN-flood攻击" class="headerlink" title="SYN flood攻击"></a>SYN flood攻击</h4><p>假设一个<code>用户向服务器发送了SYN报文后突然死机或掉线</code>，那么第三次握手无法完成，这种情况下服务器端一般会重试（再次发送SYN+ACK给客户端）并等待一段时间后丢弃这个未完成的连接，这段时间的长度称为SYN Timeout。如 果大量模拟这种情况，<code>服务器端为了维护一个非常大的半连接列表而消耗非常多的资源</code></p>
<p>SYN flood<code>只能攻击TCP服务</code>，由于UDP不需要连接，故不受影响。</p>
<h3 id="TCP的四次挥手"><a href="#TCP的四次挥手" class="headerlink" title="TCP的四次挥手"></a>TCP的四次挥手</h3><p>由于接收到<code>FIN时意味将没有数据再发来</code>，但是还是<code>可以继续发送数据</code>，所以断开连接时必须是四次握手</p>
<p>四次挥手状态图<br><img src="/images/四次挥手.jpg" alt=""></p>
<p>为什么A在TIME—WAIT状态必须等待2MSL时间呢？</p>
<ul>
<li><p><code>为了保证A发送的最后一个ACK报文段能够到达B</code><br>若该ACK报文段很有可能丢失，如果A在TIME—WAIT状态<code>不等待一段时间就直接释放连接到CLOSED状态</code>，那么就<code>无法收到B重传的FIN+ACK报文段</code>，也<code>不会再发送一次确认ACK报文段</code>，那么<code>B就无法正常进入CLOSED状态</code></p>
</li>
<li><p><code>防止已失效的请求连接出现在本连接中</code><br>在连接处于2MSL等待时，<code>任何迟到的报文段将被丢弃</code>，这样可以使下一个新的连接中不会出现这种旧的连接之前延迟的报文段。</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://murfyexp.github.io/2017/03/10/c系语言static-extern-const/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shaojie Li">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://pic2.zhimg.com/85f345ee7c2ac6bf572a9a41895a4be5_200x112.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大傻与小火机写字的地方">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/10/c系语言static-extern-const/" itemprop="url">C/C++ static extern const关键字</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-10T21:23:26-08:00">
                2017-03-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-C/" itemprop="url" rel="index">
                    <span itemprop="name">C/C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/10/c系语言static-extern-const/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/10/c系语言static-extern-const/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>static extern const三个笔试面试出场率极高的关键字，之前只是拿起来就用，出了问题就Google。为了备战春招，就特意花了些时间整理了下。思路理顺了，不管怎么考查也不怕了。</p>
<h3 id="static静态成员变量"><a href="#static静态成员变量" class="headerlink" title="static静态成员变量"></a>static静态成员变量</h3><p>总的来说，有一下三点：</p>
<blockquote>
<ul>
<li>改变变量的作用域</li>
<li>延长变量的生命周期,程序结束才会销毁</li>
<li>在同一作用域或文件中,只被初始化一次</li>
</ul>
</blockquote>
<h4 id="C-static静态成员变量"><a href="#C-static静态成员变量" class="headerlink" title="C static静态成员变量"></a>C static静态成员变量</h4><p>在C语言中，static可以用来修饰局部变量，全局变量以及函数。<code>在不同的情况下static的作用不尽相同</code></p>
<h5 id="修饰局部变量"><a href="#修饰局部变量" class="headerlink" title="修饰局部变量"></a>修饰局部变量</h5><p><code>局部变量是存放在栈区</code>，并且局部变量的生命周期在该语句块执行结束时便结束了。但是如果用static进行修饰的话，<code>变量便存放在静态数据区</code>，其生命周期<code>一直持续到整个程序执行结束</code></p>
<p>虽然用static对局部变量进行修饰过后，其<code>生命周期以及存储空间发生了变化，但是其作用域并没有改变</code>，其<code>仍然是一个局部变量</code>，作用域仅限于该语句块。<code>在用static修饰局部变量后，该变量只在初次运行时进行初始化工作，且只进行一次</code></p>
<pre><code class="lang-C">void fun()
{
    static int a=1; a++;
    printf(&quot;%d\n&quot;,a);
}

int main(void)
{
    fun();
    fun();
    return 0;  
}
</code></pre>
<p><code>程序执行结果为: 2  3</code><br>说明在第二次调用fun()函数时，a的值为2，并且没有进行初始化赋值，直接进行自增运算。</p>
<h5 id="修饰全局变量"><a href="#修饰全局变量" class="headerlink" title="修饰全局变量"></a>修饰全局变量</h5><p>一个全局变量，它既可以<code>在本源文件中被访问到，也可以在同一个工程的
其它源文件中被访问(需用extern进行声明）</code></p>
<pre><code class="lang-C">//file1.c
int a=1;

//file2.c
#include&lt;stdio.h&gt;
extern int a;
int main(void)
{
    printf(&quot;%d\&quot;,a);
    return 0;
}
</code></pre>
<p><code>执行结果为 1</code><br>但是如果在file1.c中把int a = 1改为<code>static int a=1;</code>在file2.c是<code>无法访问到变量a</code>。因为<code>static对全局变量进行修饰改变了其作用域的范围，由原来的整个工程可见变为本源文件可见</code></p>
<h5 id="修饰函数"><a href="#修饰函数" class="headerlink" title="修饰函数"></a>修饰函数</h5><p>用static修饰函数的话，情况与修饰全局变量大同小异，<code>改变了函数的作用域</code></p>
<h4 id="C-static静态成员变量-1"><a href="#C-static静态成员变量-1" class="headerlink" title="C++ static静态成员变量"></a>C++ static静态成员变量</h4><p>有时候我们希望<code>在多个对象之间共享数据</code>，对象a改变了某份数据后对象 b可以检测到。共享数据的典型使用场景是计数，以前面的Student类为例，如果我们想知道班级中共有多少名学生，就可以设置一份共享的变量，每次创建对象时让该变量加1。</p>
<p>类静态成员变量等同于全局变量。声明一个类静态成员变量做到多个实例共享一个全局变量。在C++中，我们可以<code>使用静态成员变量来实现多个对象共享数据的目标</code></p>
<p><code>static成员变量属于类，不属于某个具体的对象，即使创建多个对象，也只为 m_total分配一份内存，所有对象使用的都是这份内存中的数据</code>。当某个对象修改了m_total，也会影响到其他对象。</p>
<p>static成员变量<code>必须在类声明的外部初始化 type class::name = value;</code><br>静态成员变量既可以<code>通过对象名访问，也可以通过类名访问，但要遵循 private、protected 和 public关键字的访问权限限制</code>。</p>
<pre><code class="lang-C++">//通过类类访问 static 成员变量
Student::m_total = 10;
//通过对象来访问 static 成员变量
Student stu(&quot;小明&quot;, 15, 92.5f);
stu.m_total = 20;
//通过对象指针来访问 static 成员变量
Student *pstu = new Student(&quot;李华&quot;, 16, 96);
pstu -&gt; m_total = 20;
</code></pre>
<p>static成员变量的内存既不是在声明类时分配，也不是在创建对象时分配，而是<code>在（类外）初始化时分配</code>。反过来说，<code>没有在类外初始化的static成员变量不能使用</code></p>
<p>static成员变量不占用对象的内存，即使不创建对象也可以访问。<code>static成员变量和普通的static变量类似，都在内存分区中的全局数据区分配内存到程序结束时才释放</code>。这就意味着，static成员变量不随对象的创建而分配内存，也不随对象的销毁而释放内存。而<code>普通成员变量在对象创建时分配内存，在对象销毁时释放内存</code></p>
<p><code>初始化时可以赋初值，也可以不赋值</code>。如果不赋值，那么会被默认初始化为 0。而<code>动态数据区（堆区、栈区）变量的默认值是不确定的</code>，一般认为是垃圾值。</p>
<h4 id="C-static静态成员函数"><a href="#C-static静态成员函数" class="headerlink" title="C++ static静态成员函数"></a>C++ static静态成员函数</h4><p>静态成员函数与普通成员函数的根本区别在于：<code>普通成员函数有this指针，可以访问类中的任意成员；而静态成员函数没有this指针，只能访问静态成员（包括静态成员变量和静态成员函数）</code></p>
<pre><code class="lang-C++">//程序报错,{}则表明定义实现
static int fun4() {};
</code></pre>
<p>和静态成员变量类似，静态成员函数<code>在声明时要加 static，在定义时不能加 static。</code>静态成员函数可以通过<code>类来调用（一般都这样做），也可以通过对象来调用</code></p>
<h3 id="extern关键字"><a href="#extern关键字" class="headerlink" title="extern关键字"></a>extern关键字</h3><p>在C语言中，修饰符extern用在变量或者函数的声明前，用来说明<code>此变量/函数是在别处已定义，要在此处引用</code></p>
<p>调用其它文件中的函数和变量，只需把该文件用#include包含进来即可，为啥要用extern？<br><code>extern会加速程序的编译过程，能节省时间</code></p>
<p>在C++中extern还有另外一种作用，<code>指示C或者C＋＋函数的调用规范</code>。在C++中调用C库函数，就需要在C++程序中用extern “C”声明要引用的 函数。</p>
<p>参考链接<br><a href="http://c.biancheng.net/cpp/biancheng/view/209.html" target="_blank" rel="external">C++ static静态成员变量</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://murfyexp.github.io/2017/03/10/语言/c系语言static-extern-const/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shaojie Li">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://pic2.zhimg.com/85f345ee7c2ac6bf572a9a41895a4be5_200x112.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大傻与小火机写字的地方">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/10/语言/c系语言static-extern-const/" itemprop="url">C/C++ static extern const关键字</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-10T21:23:26-08:00">
                2017-03-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-C/" itemprop="url" rel="index">
                    <span itemprop="name">C/C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/10/语言/c系语言static-extern-const/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/10/语言/c系语言static-extern-const/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>static extern const三个笔试面试出场率极高的关键字，之前只是拿起来就用，出了问题就Google。为了备战春招，就特意花了些时间整理了下。思路理顺了，不管怎么考查也不怕了。</p>
<h3 id="static静态成员变量"><a href="#static静态成员变量" class="headerlink" title="static静态成员变量"></a>static静态成员变量</h3><p>总的来说，有一下三点：</p>
<blockquote>
<ul>
<li>改变变量的作用域</li>
<li>延长变量的生命周期,程序结束才会销毁</li>
<li>在同一作用域或文件中,只被初始化一次</li>
</ul>
</blockquote>
<h4 id="C-static静态成员变量"><a href="#C-static静态成员变量" class="headerlink" title="C static静态成员变量"></a>C static静态成员变量</h4><p>在C语言中，static可以用来修饰局部变量，全局变量以及函数。<code>在不同的情况下static的作用不尽相同</code></p>
<h5 id="修饰局部变量"><a href="#修饰局部变量" class="headerlink" title="修饰局部变量"></a>修饰局部变量</h5><p><code>局部变量是存放在栈区</code>，并且局部变量的生命周期在该语句块执行结束时便结束了。但是如果用static进行修饰的话，<code>变量便存放在静态数据区</code>，其生命周期<code>一直持续到整个程序执行结束</code></p>
<p>虽然用static对局部变量进行修饰过后，其<code>生命周期以及存储空间发生了变化，但是其作用域并没有改变</code>，其<code>仍然是一个局部变量</code>，作用域仅限于该语句块。<code>在用static修饰局部变量后，该变量只在初次运行时进行初始化工作，且只进行一次</code></p>
<pre><code class="lang-C">void fun()
{
    static int a=1; a++;
    printf(&quot;%d\n&quot;,a);
}

int main(void)
{
    fun();
    fun();
    return 0;  
}
</code></pre>
<p><code>程序执行结果为: 2  3</code><br>说明在第二次调用fun()函数时，a的值为2，并且没有进行初始化赋值，直接进行自增运算。</p>
<h5 id="修饰全局变量"><a href="#修饰全局变量" class="headerlink" title="修饰全局变量"></a>修饰全局变量</h5><p>一个全局变量，它既可以<code>在本源文件中被访问到，也可以在同一个工程的
其它源文件中被访问(需用extern进行声明）</code></p>
<pre><code class="lang-C">//file1.c
int a=1;

//file2.c
#include&lt;stdio.h&gt;
extern int a;
int main(void)
{
    printf(&quot;%d\&quot;,a);
    return 0;
}
</code></pre>
<p><code>执行结果为 1</code><br>但是如果在file1.c中把int a = 1改为<code>static int a=1;</code>在file2.c是<code>无法访问到变量a</code>。因为<code>static对全局变量进行修饰改变了其作用域的范围，由原来的整个工程可见变为本源文件可见</code></p>
<h5 id="修饰函数"><a href="#修饰函数" class="headerlink" title="修饰函数"></a>修饰函数</h5><p>用static修饰函数的话，情况与修饰全局变量大同小异，<code>改变了函数的作用域</code></p>
<h4 id="C-static静态成员变量-1"><a href="#C-static静态成员变量-1" class="headerlink" title="C++ static静态成员变量"></a>C++ static静态成员变量</h4><p>有时候我们希望<code>在多个对象之间共享数据</code>，对象a改变了某份数据后对象 b可以检测到。共享数据的典型使用场景是计数，以前面的Student类为例，如果我们想知道班级中共有多少名学生，就可以设置一份共享的变量，每次创建对象时让该变量加1。</p>
<p>类静态成员变量等同于全局变量。声明一个类静态成员变量做到多个实例共享一个全局变量。在C++中，我们可以<code>使用静态成员变量来实现多个对象共享数据的目标</code></p>
<p><code>static成员变量属于类，不属于某个具体的对象，即使创建多个对象，也只为 m_total分配一份内存，所有对象使用的都是这份内存中的数据</code>。当某个对象修改了m_total，也会影响到其他对象。</p>
<p>static成员变量<code>必须在类声明的外部初始化 type class::name = value;</code><br>静态成员变量既可以<code>通过对象名访问，也可以通过类名访问，但要遵循 private、protected 和 public关键字的访问权限限制</code>。</p>
<pre><code class="lang-C++">//通过类类访问 static 成员变量
Student::m_total = 10;
//通过对象来访问 static 成员变量
Student stu(&quot;小明&quot;, 15, 92.5f);
stu.m_total = 20;
//通过对象指针来访问 static 成员变量
Student *pstu = new Student(&quot;李华&quot;, 16, 96);
pstu -&gt; m_total = 20;
</code></pre>
<p>static成员变量的内存既不是在声明类时分配，也不是在创建对象时分配，而是<code>在（类外）初始化时分配</code>。反过来说，<code>没有在类外初始化的static成员变量不能使用</code></p>
<p>static成员变量不占用对象的内存，即使不创建对象也可以访问。<code>static成员变量和普通的static变量类似，都在内存分区中的全局数据区分配内存到程序结束时才释放</code>。这就意味着，static成员变量不随对象的创建而分配内存，也不随对象的销毁而释放内存。而<code>普通成员变量在对象创建时分配内存，在对象销毁时释放内存</code></p>
<p><code>初始化时可以赋初值，也可以不赋值</code>。如果不赋值，那么会被默认初始化为 0。而<code>动态数据区（堆区、栈区）变量的默认值是不确定的</code>，一般认为是垃圾值。</p>
<h4 id="C-static静态成员函数"><a href="#C-static静态成员函数" class="headerlink" title="C++ static静态成员函数"></a>C++ static静态成员函数</h4><p>静态成员函数与普通成员函数的根本区别在于：<code>普通成员函数有this指针，可以访问类中的任意成员；而静态成员函数没有this指针，只能访问静态成员（包括静态成员变量和静态成员函数）</code></p>
<pre><code class="lang-C++">//程序报错,{}则表明定义实现
static int fun4() {};
</code></pre>
<p>和静态成员变量类似，静态成员函数<code>在声明时要加 static，在定义时不能加 static。</code>静态成员函数可以通过<code>类来调用（一般都这样做），也可以通过对象来调用</code></p>
<h3 id="extern关键字"><a href="#extern关键字" class="headerlink" title="extern关键字"></a>extern关键字</h3><p>在C语言中，修饰符extern用在变量或者函数的声明前，用来说明<code>此变量/函数是在别处已定义，要在此处引用</code></p>
<p>调用其它文件中的函数和变量，只需把该文件用#include包含进来即可，为啥要用extern？<br><code>extern会加速程序的编译过程，能节省时间</code></p>
<p>在C++中extern还有另外一种作用，<code>指示C或者C＋＋函数的调用规范</code>。在C++中调用C库函数，就需要在C++程序中用extern “C”声明要引用的 函数。</p>
<p>参考链接<br><a href="http://c.biancheng.net/cpp/biancheng/view/209.html" target="_blank" rel="external">C++ static静态成员变量</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://murfyexp.github.io/2017/03/09/网络/DartNet/简单网络协议-SNP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shaojie Li">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://pic2.zhimg.com/85f345ee7c2ac6bf572a9a41895a4be5_200x112.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大傻与小火机写字的地方">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/09/网络/DartNet/简单网络协议-SNP/" itemprop="url">简单网络协议(SNP)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-09T15:26:15-08:00">
                2017-03-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DartNet网络协议栈/" itemprop="url" rel="index">
                    <span itemprop="name">DartNet网络协议栈</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/09/网络/DartNet/简单网络协议-SNP/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/09/网络/DartNet/简单网络协议-SNP/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在前面的文章中，我们在DartNet覆盖网络（ON）层上直接实现了SRT。现在我们需要添加路由和分组转发到DartNet。本篇文章将<code>介绍DartNet网络层的设计，并实现简单网络协议（SNP），以提供类似于在互联网路由器上运行的IP协议和路由的转发。</code></p>
<p>本篇文章的具体内容：</p>
<blockquote>
<ul>
<li>SNP API</li>
<li>SNP路由协议</li>
<li>SNP数据包转发</li>
<li>SNP过程实现</li>
</ul>
</blockquote>
<h3 id="DartNet"><a href="#DartNet" class="headerlink" title="DartNet"></a>DartNet</h3><p>在DartNet中，<code>在每对相邻节点之间存在TCP连接</code>。<code>在每个节点上，存在覆盖网络（ON）层，简单网络协议（SNP）层，简单可靠传输（SRT）层和应用层</code></p>
<p>ON进程包含n + 1个线程，其中n是相邻节点的数目。对于这些ON线程，<code>一个是主线程，另外n个线程是listen_to_neighbor线程</code>。实现覆盖网络（ON）层</p>
<p>SNP进程包含3个线程：<code>主线程，pkthandler线程和routeupdate_daemon线程</code>。实现简单网络协议（SNP）层</p>
<p>SRT进程包含两个线程：<code>主线程和seghandler线程</code>。实现SRT层和应用层。</p>
<p>DartNet实现图<br><img src="/images/DartNet/DartNet.png" alt=""></p>
<h3 id="SNP-API"><a href="#SNP-API" class="headerlink" title="SNP API"></a>SNP API</h3><p>DartNet API调用图<br><img src="/images/DartNet/DartNet APIs.png" alt=""></p>
<p>SNP进程向SRT进程提供两个函数：snp_sendseg（）和snp_recvseg（）。我们之前实现了这两个SNP API。然而在那时，这些SNP API是使用两个节点之间的直接TCP连接来实现的。<code>在这里我们将使用ON层重新实现这些API</code></p>
<p>SRT进程调用snp_sendseg（）将段发送到目标节点。当SRT进程调用<code>snp_sendseg（）</code>时，sendseg_arg_t结构被发送到本地SNP进程。本地SNP进程使用<code>getsegToSend（）接收此sendseg_arg_t结构。</code>然后，本地SNP进程将每个分段封装到一个分组中，并使用<code>overlay_sendpkt（）将分组发送到下一跳</code>。</p>
<p>SNP进程通过调用<code>overlay_recvpkt（）</code>函数从本地ON进程接收数据包。在SNP过程接收到分组之后，SNP过程从分组的数据字段中提取分段，并且<code>向本地SRT过程转发sendseg_arg_t结构</code>。本地SRT进程调用<code>snp_recvseg（）</code>接收此sendseg_arg_t结构。</p>
<p>sendseg_arg_t在seg.h中定义</p>
<pre><code class="lang-C">//This is the data structure exchanged between the SNP process and the SRT process.
//It contains a node ID and a segment.
//For snp_sendseg(), the node ID is the destination node ID of the segment.
//For snp_recvseg(), the node ID is the source node ID of the segment.

typedef struct sendsegargument {
  int nodeID;   //node ID
  seg_t seg;    //a segment
} sendseg_arg_t;
</code></pre>
<h3 id="SNP路由协议"><a href="#SNP路由协议" class="headerlink" title="SNP路由协议"></a>SNP路由协议</h3><p>SNP路由协议是<code>距离矢量路由协</code>议。SNP路由协议使用<code>链路成本作为路由度量</code>。当两个节点之间存在多条路径时，应选择总链路成本较小的路径。我们先看看SNP路由协议使用的数据结构。然后讨论SNP路由算法。</p>
<p>SNP路由协议使用3个表：<code>邻居成本表，距离向量表和路由表</code>。我们将一一讨论它们。<code>覆盖中的每个节点都有一个SNP进程在其上运行</code>，每个SNP进程维护一个邻居成本表，一个距离向量表和一个路由表，用于运行它的节点。</p>
<h4 id="邻居链路成本表"><a href="#邻居链路成本表" class="headerlink" title="邻居链路成本表"></a>邻居链路成本表</h4><p>节点的邻居成本表包含到其所有邻居的直接链路成本。邻居成本表具有n个条目，其中n是节点的邻居的数量。邻居成本表项在network / nbrcosttable.h中定义。</p>
<pre><code class="lang-C">//neighbor cost table entry definition

typedef struct neighborcostentry {
  unsigned int nodeID;  //neighbor’s node ID
  unsigned int cost;    //direct link cost to the neighbor
} nbr_cost_entry_t;
</code></pre>
<p>当<code>SNP过程开始时，动态创建邻居表</code>。邻居成本表通过<code>解析topology.dat中包含的拓扑信息来初始化</code>。</p>
<h4 id="距离向量表"><a href="#距离向量表" class="headerlink" title="距离向量表"></a>距离向量表</h4><p><code>距离向量表包含从源节点到网络中所有节点的估计的链路成本</code>。距离向量结构在network / dvtable.h中定义</p>
<pre><code class="lang-C">//distance vector entry definition

typedef struct distancevectorentry {
  int nodeID;         //destination nodeID
  unsigned int cost;  //estimated link cost to the destination
} dv_entry_t;

//distance vector definition

typedef struct distancevector {
  int         nodeID;   //source nodeID
  dv_entry_t  *dvEntry; //an array of N dv_entry_ts, each of which contains the
                //destination node ID and the estimated link cost to the destination
                //from the source node. N is the total number of nodes in the overlay.
} dv_t;
</code></pre>
<p>dv_t是一个距离向量，其包含<code>源nodeID和N个dv_entry_t结构的数组</code>，其中N是覆盖中的节点总数(表中的横坐标)。<code>dv_entry_t包含目的节点ID和到目的地节点的链路成本</code>。距离向量表包含n + 1个距离向量 (表中的纵坐标)，其中<code>n是节点的邻居的数目，另一个为节点本身</code>。</p>
<p><code>当SNP过程开始时，动态创建距离向量表</code>。使用来自topology.dat文件的链路成本信息来<code>初始化节点自身的距离向量</code>。目的地节点为节点本身，则链路成本为0。目的地节点是相邻节点，链路成本是直接链路成本。否则，估计的链接成本为INFINITE_COST。距离向量表中的相邻节点的其他距离向量用INFINITE_COST初始化。</p>
<h4 id="路由表"><a href="#路由表" class="headerlink" title="路由表"></a>路由表</h4><p>路由表是具有MAX_ROUTINGTABLE_SLOTS个元素的散列表。每个元素指向一个routingtable_entry_t链表。<code>使用链表解决冲突。</code>routingtable_entry_t结构和路由表本身在network/routingtable.h中定义。</p>
<p>路由表<br><img src="/images/DartNet/Network_Files/Routing Table Structure.png" alt=""></p>
<pre><code class="lang-C">//routingtable_entry_t is the routing entry contained in the routing table.

typedef struct routingtable_entry {
  int destNodeID;                   //destination node ID
  int nextNodeID;                   //next node ID to which the packet should be forwarded
  struct routingtable_entry* next;  //pointer to the next routingtable_entry_t in the same routing table slot
} routingtable_entry_t;

//A routing table is a hash table containing MAX_ROUTINGTABLE_SLOTS slots.
//Each slot is a linked list of routing entries.

typedef struct routingtable {
  routingtable_entry_t* hash[MAX_ROUTINGTABLE_SLOTS];
} routingtable_t;
</code></pre>
<p><code>routing_entry_t结构包含此目标节点的ID和下一跳的nodeID</code>。路由表是一个哈希表。makehash（）是哈希表的散列函数，<code>键值为目标节点ID，散列值为目标节点在哈希表的槽号</code></p>
<p>要将路由entry<code>添加</code>到路由表，首先使用散列函数makehash（）来获取应存储此路由entry槽号。然后将路由entry插入该槽中的链表中。要<code>查找</code>一个目标路由entry，过程与添加类似</p>
<p><code>通过为所有相邻节点添加路由entry来初始化路由表</code>，对于作为目的地节点的每个相邻节点，将下一跳节点设置为相邻节点本身。</p>
<h3 id="SNP路由算法"><a href="#SNP路由算法" class="headerlink" title="SNP路由算法"></a>SNP路由算法</h3><p>SNP路由协议使用距离向量路由算法。具体原理与实现，可以自行阅读《计算机网咯：自顶向下方法》中的距离矢量（DV）路由算法。</p>
<p>当SNP进程启动时，它启动一个routeupdate_daemon线程。<code>routeupdate_daemon线程每ROUTEUPDATE_INTERVAL时间间隔广播一个路由更新包</code>。该路由更新包的内容是源节点的距离向量。<code>接收方的距离向量表和路由表根据此距离向量信息
更新相应的表项</code>。接收方不会转发接收到的路由更新包，<code>路由更新只会被源节点的直接邻居接收</code>。</p>
<p>SNP路由算法实现过程中，用图片的形式，表示各表内容的变化。</p>
<p>DartNet拓扑<br><img src="/images/DartNet/Network_Files/DartNet topology.png" alt=""></p>
<p>邻居链路成本表<br><img src="/images/DartNet/Network_Files/Neighbor Cost Tables.png" alt=""></p>
<p><code>初始化后</code>，节点的距离向量表和路由表<code>显示在图的左侧</code>。<br>在所有节点接收到来自它们的邻居的所有<code>第一路由更新分组之后</code>，距离向量表更新并且在<code>图的右侧示出</code><br><img src="/images/DartNet/Network_Files/Distance Vector Tables in Step 1.png" alt=""></p>
<p>在所有节点从其邻居接收到<code>第二路由更新分组之后的距离向量表和路由表</code><br><img src="/images/DartNet/Network_Files/Distance Vector Tables in Step 2.png" alt=""></p>
<p><img src="/images/DartNet/Network_Files/Routing Tables.png" alt=""></p>
<h3 id="数据包转发"><a href="#数据包转发" class="headerlink" title="数据包转发"></a>数据包转发</h3><p>在SNP过程中，<code>分组转发在pkthandler线程中完成</code>。pkthandler线程通过调用overlay_recvpkt（）从<code>ON进程接收数据包</code>。</p>
<p>如果接收的<code>分组是SNP分组，并且目的地节点是该节点</code>，则pkthandler线程将分组转发到SRT进程。<br>如果分组是<code>SNP分组，并且目的地节点不是该节点</code>，则pkthandler线程根据路由表将分组转发到下一跳。<br>如果该分组是<code>路由更新分组</code>，则pkthandler线程使用我们上面描述的SNP路由算法来更新距离向量表和路由表。</p>
<h3 id="SNP过程实现"><a href="#SNP过程实现" class="headerlink" title="SNP过程实现"></a>SNP过程实现</h3><p><code>SNP作为进程运行</code>。<code>覆盖层中的每个节点</code>都有一个SNP进程在其上运行。SNP进程的代码如下所示：</p>
<pre><code class="lang-C">printf(&quot;network layer is starting, pls wait...\n&quot;);

  //initialize global variables
  nct = nbrcosttable_create();
  dv = dvtable_create();
  dv_mutex = (pthread_mutex_t*)malloc(sizeof(pthread_mutex_t));
  pthread_mutex_init(dv_mutex,NULL);
  routingtable = routingtable_create();
  routingtable_mutex = (pthread_mutex_t*)malloc(sizeof(pthread_mutex_t));
  pthread_mutex_init(routingtable_mutex,NULL);
  overlay_conn = -1;
  transport_conn = -1;

  nbrcosttable_print(nct);
  dvtable_print(dv);
  routingtable_print(routingtable);

  //register a signal handler which is used to terminate the process
  signal(SIGINT, network_stop);

  //connect to local ON process
  overlay_conn = connectToOverlay();
  if (overlay_conn&lt;0) {
    printf(&quot;can’t connect to overlay process\n&quot;);
    exit(1);
  }

  //start a thread that handles incoming packets from ON process
  pthread_t pkt_handler_thread;
  pthread_create(&amp;pkt_handler_thread,NULL,pkthandler,(void*)0);

  //start a route update thread
  pthread_t routeupdate_thread;
  pthread_create(&amp;routeupdate_thread,NULL,routeupdate_daemon,(void*)0);

  printf(&quot;network layer is started...\n&quot;);
  printf(&quot;waiting for routes to be established\n&quot;);
  sleep(NETWORK_WAITTIME);
  routingtable_print(routingtable);

  //wait connection from SRT process
  printf(&quot;waiting for connection from SRT process\n&quot;);
  waitTransport();
</code></pre>
<p>当SNP过程开始时，首先建表并初始化这些表。SNP过程还创建和初始化<code>两个互斥：一个用于向量表，另一个用于路由表</code>。</p>
<p><code>overlay_conn为SNP进程与本地ON进程的连接的TCP描述符和transport_conn为SNP进程与本地SRT进程的连接的TCP描述符</code>。当SNP过程开始时，SNP过程将overlay_conn和transport_conn初始化为-1作为无效。</p>
<p>然后，SNP进程将信号处理程序network_stop（）注册到信号SIGINT，使得当接收到SIGINT信号时，调用network_stop（）以终止SNP进程。SNP进程调用函数<code>connectToOverlay（）连接到端口OVERLAY_PORT上的本地ON进程</code></p>
<p><code>在建立与ON进程的TCP连接之后，SNP进程启动pkthandler线程。接着启动routeupdate_daemon线程</code>。然后，SNP过程等待一段时间，<code>以便路由表更新完成</code></p>
<p>SNP进程然后调用<code>waitTransport（）函数在NETWORK_PORT上打开一个端口来等待来自本地SRT进程的TCP连接</code>。连接本地SRT进程后，waitTransport（）函数接收sendseg_arg_t结构，<code>其中包含来自SRT进程的段及其目标nodeID。将接收的段封装重新封装，并使用overlay_sendpkt发送到下一跳</code>。从路由表中检索下一跳的节点ID。</p>
<p>SNP过程在接收到<code>SIGINT信号时终止</code>。当接收到SIGINT信号时，信号处理器函数<code>network_stop（）通过关闭所有TCP连接，释放所有动态分配的内存并终止SNP进程来停止覆盖</code></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://murfyexp.github.io/2017/03/08/网络/DartNet/简单覆盖网络-SON/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shaojie Li">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://pic2.zhimg.com/85f345ee7c2ac6bf572a9a41895a4be5_200x112.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大傻与小火机写字的地方">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/08/网络/DartNet/简单覆盖网络-SON/" itemprop="url">简单覆盖网络(SON)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-08T16:48:51-08:00">
                2017-03-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DartNet网络协议栈/" itemprop="url" rel="index">
                    <span itemprop="name">DartNet网络协议栈</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/08/网络/DartNet/简单覆盖网络-SON/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/08/网络/DartNet/简单覆盖网络-SON/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我们已经实现了DartNet的SRT协议。<code>之所以设计覆盖层</code>，因为我们不能在互联网的真实路由器上运行我们的简单网络协议（SNP）。<code>这是一个非常酷的方法来绕过不能更改路由器代码的限制</code>。带上你的好奇心，开始了解它吧。在本篇文章，我们将讨论覆盖网络层的设计</p>
<p>本篇文章的具体内容：</p>
<blockquote>
<ul>
<li>覆盖层拓扑和节点ID</li>
<li>覆盖层的构造</li>
<li>邻居表</li>
<li>SNP数据包格式</li>
<li>覆盖过程实现</li>
<li>测试叠加</li>
</ul>
</blockquote>
<h3 id="覆盖层拓扑和节点ID"><a href="#覆盖层拓扑和节点ID" class="headerlink" title="覆盖层拓扑和节点ID"></a>覆盖层拓扑和节点ID</h3><p>DartNet建立在覆盖层网络上。这个覆盖层网络的拓扑在topology.dat文件中定义。topology.dat中的每一行具有以下格式：<br><code>host1 host2 link cost</code></p>
<p>其中host1是计算机的主机名，host2是另一台计算机的主机名，link cost是这两个主机之间的直接链接开销。</p>
<p>覆盖拓扑<br><img src="/images/DartNet/Overlay/overlay0x.png" alt=""></p>
<p>在DartNet中，使用nodeID来标识主机。<code>nodeID与TCP/IP中的IP地址具有类似 的作用</code>。nodeID是由主机<code>IP地址的后8位</code>表示的整数。例如，IP地址为“202.120.95.36”的主机作为节点ID 36。</p>
<h3 id="覆盖层的构造"><a href="#覆盖层的构造" class="headerlink" title="覆盖层的构造"></a>覆盖层的构造</h3><p>我们的覆盖层网络中有4个节点。在每个节点上，有一个ON进程和SNP进程在运行。<code>ON进程和SNP进程与本地TCP连接相连。ON过程还保持与所有相邻节点的TCP连接</code>。例如，左上节点在覆盖网络中具有3个相邻节点。存在到每个相邻节点的TCP连接。</p>
<p>覆盖过程图<br><img src="/images/DartNet/Overlay/overlay1x.png" alt=""></p>
<p>节点到邻居的每个TCP连接，都有一个listen_to_neighbor线程。<code>listen_to_neighbor线程保持从该邻居接收分组并且将接收的分组转发到SNP进程</code>。对于ON进程和SNP进程之间的TCP连接，<code>主线程继续从SNP进程接收包含分组和下一跳的nodeID的sendpkt_arg_t结构，并将这些分组发送到下一跳节点</code>。</p>
<p>左上节点的ON线程图<br><img src="/images/DartNet/Overlay/overlay2x.png" alt=""></p>
<h3 id="邻居表"><a href="#邻居表" class="headerlink" title="邻居表"></a>邻居表</h3><p>ON进程维护邻居表。邻居表包含相邻节点的信息。邻居表在overlay / neighbortable.h中定义</p>
<pre><code class="lang-C">//neighbortable entry definition
//a neighbor table contains n entries where n is the number of neighbors

typedef struct neighborentry {
  int nodeID;       //neighbor’s node ID
  in_addr_t nodeIP; //neighbor’s IP address
  int conn;         //TCP connection’s socket descriptor to the neighbor
} nbr_entry_t;
</code></pre>
<p>邻居表具有n个entry，其中n是覆盖层中的邻居的数目。邻居表中的每个entry包含<code>邻居的nodeID，邻居的IP地址和TCP连接对邻居的套接字描述符</code>。</p>
<h3 id="SNP数据包格式"><a href="#SNP数据包格式" class="headerlink" title="SNP数据包格式"></a>SNP数据包格式</h3><p>ON过程<code>从覆盖层网络接收</code>SNP分组并<code>转发到SNP层</code>。ON过程还<code>从SNP层接收</code>SNP分组，并<code>转发到覆盖层网络</code>。SNP包格式在common / pkt.h中定义</p>
<p>数据包格式图<br><img src="/images/DartNet/Overlay/Packet.png" alt=""></p>
<pre><code class="lang-C">//packet type definition, used for type field in the SNP header
#define ROUTE_UPDATE 1
#define SNP 2

//SNP packet format definition
typedef struct snpheader {
  int src_nodeID;               //source node ID
  int dest_nodeID;              //destination node ID
  unsigned short int length;    //length of the data in the packet
  unsigned short int type;      //type of the packet
} snp_hdr_t;

typedef struct packet {
  snp_hdr_t header;
  char data[MAX_PKT_LEN];
} snp_pkt_t;
</code></pre>
<p>如果分组类型等于SNP，则分组中包含的数据将是<code>一个段（包括段头和数据）</code>。如果分组的类型是ROUTE_UPDATE，则<code>节点的距离向量包含在分组的数据字段中。</code></p>
<pre><code class="lang-C">//A route update entry

typedef struct routeupdate_entry {
  unsigned int nodeID;  // destination nodeID
  unsigned int cost; // link cost between source (src_nodeID in header) and destination nodes
} routeupdate_entry_t;

//route update packet format

typedef struct pktrt{
  unsigned int entryNum;  // number of entries contained and in this route update packet
  routeupdate_entry_t entry[MAX_NODE_NUM];
} pkt_routeupdate_t;
</code></pre>
<p>路由更新数据包格式<br><img src="/images/DartNet/Overlay/Route Update Packet.png" alt=""></p>
<p>覆盖层网络API<br><img src="/images/DartNet/Overlay/overlay5x.png" alt=""></p>
<p>通过TCP连接发送数据时，我们使用分隔符。使用“！＆”表示数据传输的开始，使用“！＃”表示数据传输的结束。因此，<code>当数据通过TCP连接发送时，首先发送“！＆”，然后发送数据，然后发送“！＃”。</code>接收方只需相应地根据分割符进行解析接受即可</p>
<h4 id="API的说明"><a href="#API的说明" class="headerlink" title="API的说明"></a>API的说明</h4><p>ON进程为SNP进程提供两个函数调用：<code>overlay_sendpkt（）和overlay_recvpkt（）。</code></p>
<pre><code class="lang-C">typedef struct sendpktargument {
  int nextNodeID;    //node ID of the next hop
  pkt_t pkt;         //the packet to be sent
} sendpkt_arg_t

int overlay_sendpkt(int nextNodeID, pkt_t* pkt, int overlay_conn)
int overlay_recvpkt(pkt_t* pkt, int overlay_conn)
</code></pre>
<p>ON进程使用<code>getpktToSend（）</code>获取一个sendpkt_arg_t数据结构，该结构包含一个数据包和来自SNP进程的下一跳的nodeID。ON进程使用<code>forwardpktToSNP（）</code>将数据包转发到SNP进程。</p>
<pre><code class="lang-C">int getpktToSend(pkt_t* pkt, int* nextNode,int network_conn);
int forwardpktToSNP(pkt_t* pkt, int network_conn);
</code></pre>
<p>ON进程使用<code>sendpkt（）</code>向邻居发送数据包，并使用<code>recvpkt（）</code>从邻居接收数据包。</p>
<pre><code class="lang-C">int sendpkt(pkt_t* pkt, int conn);
int recvpkt(pkt_t* pkt, int conn);
</code></pre>
<h3 id="覆盖过程实现"><a href="#覆盖过程实现" class="headerlink" title="覆盖过程实现"></a>覆盖过程实现</h3><p>ON过程的代码如下</p>
<pre><code class="lang-C">//start overlay initialization
  printf(&quot;Overlay: Node %d initializing...\n&quot;, topology_getMyNodeID());

  //create a neighbor table
  nt = nt_create();

  //initialize network_conn to -1, means no network layer process is connected yet
  network_conn = -1;

  //register a signal handler which is used to terminate the process
  signal(SIGINT, overlay_stop);

  //print out all the neighbors
  int nbrNum = topology_getNbrNum();
  int i;
  for(i=0;i&lt;nbrNum;i++) {
    printf(&quot;Overlay: neighbor %d:%d\n&quot;,i+1,nt[i].nodeID);
  }

  //start the waitNbrs thread to wait for incoming connections
  //from neighbors with larger node IDs

  pthread_t waitNbrs_thread;
  pthread_create(&amp;waitNbrs_thread,NULL,waitNbrs,(void*)0);

  //wait for neighboring nodes to start the overlay process

  sleep(OVERLAY_START_DELAY);

  //connect to neighbors with smaller node IDs

  connectNbrs();

  //wait for waitNbrs thread to return

  pthread_join(waitNbrs_thread,NULL);

  //at this point, all connections to the neighbors are created

  //create threads listening to all the neighbors

  for(i=0;i&lt;nbrNum;i++) {
    int* idx = (int*)malloc(sizeof(int));
    *idx = i;
    pthread_t nbr_listen_thread;
    pthread_create(&amp;nbr_listen_thread,NULL,listen_to_neighbor,(void*)idx);
  }

  printf(&quot;Overlay: node initialized...\n&quot;);
  printf(&quot;Overlay: waiting for connection from SNP process...\n&quot;);

  //waiting for connection from  SNP process

  waitNetwork();
</code></pre>
<p>当ON进程启动时，创建并初始化邻居表。然后<code>注册信号处理器overlay_stop（）用于信号SIGINT</code>，当接收到SIGINT信号时，调用overlay_stop（）以终止ON过程。</p>
<p>建立到覆盖网络中的所有邻居的TCP连接。在我们的设计中，如果两个节点之间存在链接，则<code>具有较小节点ID的节点将在CONNECTION_PORT上打开一个TCP端口，具有较大节点ID的节点将连接到该节点</code></p>
<p><code>ON进程启动waitNbrs线程，然后一段时间后调用connectNbrs（）函数</code>。waitNbrs线程在<code>CONNECTION_PORT上打开一个TCP端口，并等待来自节点ID比自身节点ID大的所有邻居的传入连接</code>。待所有传入连接建立后，waitNbrs线程返回。</p>
<p>对于与邻居的每个TCP连接，ON过程启动listen_to_neighbor线程。<code>每个listen_to_neighbor线程使用recvpkt（）保持从邻居接收数据包，并使用forwardpktToSNP（）将数据包转发到SNP进程。</code></p>
<p><code>当所有的listen_to_neighbor线程都启动，ON进程调用waitNetwork（）函数。</code>此函数<code>在OVERLAY_PORT上打开一个TCP端口</code>，并等待来自<code>本地SNP进程TCP连接</code>。建立连接后，waitNetwork（）函数继续<code>从SNP进程接收sendpkt_arg_t结构</code>。之后waitNetwork（）使用<code>sendpkt（）将数据包发送到覆盖层网络中的下一跳</code>。当SNP进程断开时，waitNetwork（）<code>关闭连接并等待来自本地SNP进程的下一个连接</code></p>
<p><code>ON进程在接收到SIGINT信号时终止</code>。关闭所有TCP连接，释放所有动态分配的内存并终止ON过程来停止覆盖</p>
<h3 id="测试叠加层"><a href="#测试叠加层" class="headerlink" title="测试叠加层"></a>测试叠加层</h3><p>SNP进程连接到本地ON进程，并且请求本地过程周期性地广播路由更新分组。SNP过程应该能够从其邻居接收路由更新分组。通过发送和接收路由更新分组，我们可以验证覆盖是否正常工作。</p>
<pre><code class="lang-C">printf(&quot;network layer is starting, pls wait...\n&quot;);

  //initialize global variables

  overlay_conn = -1;

  //register a signal handler which will kill the process

  signal(SIGINT, network_stop);

  //connect to overlay

  overlay_conn = connectToOverlay();
  if(overlay_conn&lt;0) {
    printf(&quot;can’t connect to ON process\n&quot;);
    exit(1);
  }

  //start a thread that handles incoming packets from overlay

  pthread_t pkt_handler_thread;
  pthread_create(&amp;pkt_handler_thread,NULL,pkthandler,(void*)0);

  //start a route update thread

  pthread_t routeupdate_thread;
  pthread_create(&amp;routeupdate_thread,NULL,routeupdate_daemon,(void*)0);

  printf(&quot;network layer is started...\n&quot;);

  //sleep forever
  while(1) {
    sleep(60);
  }
</code></pre>
<p><code>在ON进程中调用waitNetwork（）后，SNP进程启动</code>。当SNP过程开始时，SNP过程首先通过将与本地ON过程的连接设置为-1作为无效。</p>
<p>然后SNP进程<code>调用connecToOverlay（）函数连接到端口OVERLAY_PORT上的ON进程</code>。在建立与ON进程的TCP连接之后，<code>SNP进程启动pkthandler线程处理来自ON进程的传入数据包，启动routeupdate_daemon线程广播路由更新</code>。目前，广播路由<code>更新报文</code>。广播通过将SNP分组报头中的<code>dest_nodeID设置为BROADCAST_NODEID</code>来完成，并<code>使用overlay_sendpkt（）将路由更新分组发送到广播地址BROADCAST_NODEID</code></p>
<p>最后SNP进程进入while循环，并永久休眠。当接收到SIGINT信号时终止SNP进程。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://murfyexp.github.io/2017/03/03/linux网络编程/socket套接字编程教程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shaojie Li">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://pic2.zhimg.com/85f345ee7c2ac6bf572a9a41895a4be5_200x112.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大傻与小火机写字的地方">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/03/linux网络编程/socket套接字编程教程/" itemprop="url">socket套接字编程教程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-03T23:22:09-08:00">
                2017-03-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux网络编程/" itemprop="url" rel="index">
                    <span itemprop="name">Linux网络编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/03/linux网络编程/socket套接字编程教程/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/03/linux网络编程/socket套接字编程教程/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>socket套接字工作于TCP/IP协议中应用层和传输层之间的一个抽象，使得网络上不同的计算机可以进行通信。</p>
<p>在客户端上建立套接字的步骤如下：</p>
<blockquote>
<ul>
<li>socket()创建套接字</li>
<li>connect()将套接字连接到服务器</li>
<li>使用read()和write()发送和接收数据</li>
</ul>
</blockquote>
<p>在服务器端建立套接字的步骤如下：</p>
<blockquote>
<ul>
<li>socket()创建套接字</li>
<li>使用bind()系统调用将套接字绑定到地址，地址由主机上的端口号组成。</li>
<li>listen()监听连接</li>
<li>accept()接受连接。此调用通常阻塞，直到客户端与服务器连接</li>
<li>发送和接收数据</li>
</ul>
</blockquote>
<p>CS模式下API图<br><img src="/images/cs_Socket.png" alt="CS模式"></p>
<h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>sockfd和newsockfd文件描述符，这两个变量存储套接字系统call和accept系统调用返回的</p>
<pre><code class="lang-C">struct sockaddr_in serv_addr，cli_addr;
</code></pre>
<p>sockaddr_in是互联网地址结构。定义在<netinet in.h="">。变量serv_addr为服务器的地址，cli_addr是客户端的地址。</netinet></p>
<pre><code class="lang-C">struct sockaddr_in
{
    short sin_family;
    u_short sin_port;
    struct in_addr sin_addr;
    char sin_zero [8];
};
</code></pre>
<p>in_addr结构，在相同的头文件中定义，只包含一个无符号长整型s_addr。</p>
<pre><code class="lang-C">if (argc &lt; 2) 
{
    fprintf(stderr,&quot;ERROR, no port provided\n&quot;);
    exit(1);
}
</code></pre>
<p>用户需要传入服务器的端口号，若未执行此操作就报错</p>
<pre><code class="lang-C">sockfd = socket(AF_INET, SOCK_STREAM, 0);
if (sockfd &lt; 0)
    error(&quot;ERROR opening socket&quot;);
</code></pre>
<p>socket()创建一个套接字，它需要三个参数。<br>第一个是套接字的地址域。2种：共享文件系统的两个进程的unix域，以及Internet上任意两个主机的Internet域。符号常数AF_UNIX用于前者，而AF_INET后者</p>
<p>第二个参数是套接字的类型。2种：来自文件或管道的流套接字，以及以块读取消息的数据报套接字。符号常量是SOCK_STREAM和SOCK_DGRAM。</p>
<p>第三个参数是协议。如果此参数为零，操作系统将选择最适当的协议。它将选择TCP作为流套接字，UDP选择数据报套接字。</p>
<p>套接字调用返回文件描述符表的一个表项。此值用于对此套接字的所有后续引用。如果套接字调用失败，它返回-1。在这种情况下，程序显示和错误消息并退出。<br>上面是套接字调用的简化描述；还有许多其他选择域和类型，但这些是最常见的</p>
<pre><code class="lang-C">bzero((char *) &amp;serv_addr, sizeof(serv_addr));
</code></pre>
<p>该函数bzero()将缓冲区中的所有值设置为零。它有两个参数，第一个是指向缓冲区的指针，第二个是缓冲区的大小。因此，此行初始化 serv_addr为零。</p>
<pre><code class="lang-C">portno = atoi(argv[1]);
</code></pre>
<p>服务器将侦听连接的端口号作为参数传入，并使用该atoi()函数将其从数字字符串转换为整数</p>
<pre><code class="lang-C">serv_addr.sin_family = AF_INET;
</code></pre>
<p>short sin_family用于记录地址，它始终设置为符号常量AF_INET。</p>
<pre><code class="lang-C">serv_addr.sin_addr.s_addr = INADDR_ANY;
</code></pre>
<p>unsigned long s_addr，记录主机的IP地址。对于服务器，这将始终是运行服务器的计算机的IP地址，INADDR_ANY是获得此地址的符号常量。</p>
<pre><code class="lang-C">serv_addr.sin_port = htons(portno);
</code></pre>
<p>unsigned short sin_port，记录端口号。这里需要使用将主机字节顺序中的端口号转换为网络字节顺序中的端口号。</p>
<pre><code class="lang-C">if (bind(sockfd, (struct sockaddr *) &amp;serv_addr,
        sizeof(serv_addr)) &lt; 0)
error(&quot;ERROR on binding&quot;);
</code></pre>
<p>bind()将套接字绑定到一个地址上。它需要三个参数：套接字文件描述符，绑定的地址和绑定的地址的大小。第二个参数是sockaddr类型，但传入的是sockaddr_in，因此必须将它转换为正确的类型。<br>bind()过程失败的原因有很多，最明显的是该套接字已经在这台机器上使用。 </p>
<pre><code class="lang-C">listen(sockfd,5);
</code></pre>
<p>listen（sockfd，5）;<br>listen监听该套接字连接。第一个参数是套接字文件描述符，第二个参数是等待连接的队列大小</p>
<pre><code class="lang-C">clilen = sizeof(cli_addr);
newsockfd = accept(sockfd, (struct sockaddr *) &amp;cli_addr, &amp;clilen);
if (newsockfd &lt; 0)
    error(&quot;ERROR on accept&quot;);
</code></pre>
<p>accept()导致进程阻塞，直到客户端连接到服务器。当连接成功时，它唤醒该进程。返回一个新的文件描述符，并使用这个新的文件描述符完成此连接上的所有通信。第二个参数是指向连接另一端的客户端地址的引用指针，第三个参数是此结构的大小。</p>
<pre><code class="lang-C">bzero(buffer,256);
n = read(newsockfd,buffer,255);
if (n &lt; 0) error(&quot;ERROR reading from socket&quot;);
printf(&quot;Here is the message: %s\n&quot;,buffer);
</code></pre>
<p>使用bzero()函数初始化缓冲区，然后从套接字读取信息。read()使用新的文件描述符，阻塞直到有一些东西可读，即客户端已经执行write()后。它将读取套接字中的字符，并返回读取的字符数。 </p>
<pre><code class="lang-C">n = write(newsockfd,&quot;I got your message&quot;,18);
if (n &lt; 0) error(&quot;ERROR writing to socket&quot;);
</code></pre>
<p>一旦建立了连接，两端都可以读写。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://murfyexp.github.io/2017/03/02/操作系统/内存管理(页面管理)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shaojie Li">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://pic2.zhimg.com/85f345ee7c2ac6bf572a9a41895a4be5_200x112.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大傻与小火机写字的地方">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/02/操作系统/内存管理(页面管理)/" itemprop="url">内存管理(页面管理)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-02T10:51:13-08:00">
                2017-03-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JOS操作系统/" itemprop="url" rel="index">
                    <span itemprop="name">JOS操作系统</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/02/操作系统/内存管理(页面管理)/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/02/操作系统/内存管理(页面管理)/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>内存管理模块分为2部分：<code>物理页面管理和页表管理</code>。前者强调对机器拥有的<code>物理内存的管理</code>，包括建立对应的数据结构、处理分配和回收动作等。而后者主要是强调利用Intel x86系列处理器的<code>页式地址管理功能，
完成(虚拟)线性地址到物理地址的转换</code>，包括建立页目录、页表等。</p>
<p>物理页面管理相关的函数：</p>
<blockquote>
<ul>
<li>boot_alloc()</li>
<li>page_init()</li>
<li>page_alloc()</li>
<li>page_free() </li>
</ul>
</blockquote>
<h3 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h3><p>JOS的启动过程是先把bootsector的内容读到0x7c00处，bootsector中的代码开始执行后，会从磁盘上紧接着自己的第2个扇区开始，一直读8个扇区的内容(一共是8×512=4KB，ELF头的大小)到0x10000(64KB)的地方，然后通过对ELF头的解析，得到kernel模块编译出来后所占的大小，并将kernel读到物理内存0x100000(1MB)开始的地方。</p>
<p><img src="/images/JOS/内存layout.png" alt="3"></p>
<p>然后设置好GDT，并调用i386_init()函数，而i386_init()函数在将自己的BSS区域清零后，调用cons_init()函数设置屏幕显示，为cprintf的运行做 好准备。随后调用i386_detect_memory()函数和i386_vm_init()。后者就是我们内存管理的主要函数了</p>
<blockquote>
<p>.bss 节:未初始化的全局变量部分，一部分不会在磁盘有存储空间，因为这些变量并没有被初始化，因此全部默认为0，在将这节装入到内存的时候程序需要为其分配相应大小的初始值为0的内存空间</p>
</blockquote>
<p>在调用i386_init()后，系统将重载GDT，新的GDT：</p>
<pre><code class="lang-x86asm">SEG_NULL # null seg
SEG(STA_X|STA_R， -KERNBASE， 0xffffffff) # code seg
SEG(STA_W， -KERNBASE， 0xffffffff) # data seg
</code></pre>
<p>新GDT后两项的base，它们是-KERNBASE。如果KERNBASE=0xF0000000，则<br>GDT的base=0x10000000</p>
<h3 id="页面管理"><a href="#页面管理" class="headerlink" title="页面管理"></a>页面管理</h3><p>JOS内核是<code>以页(page)为最小单位，通过链表来管理内存的</code>。它使用<code>MMU来映射，保护每一块被分配出去的内存</code>。操作系统必须要追踪记录哪些内存区域是空闲的，哪些是被占用的。</p>
<p>页面管理相关的数据结构</p>
<pre><code class="lang-C">typedef uint32_t pte_t;
typedef uint32_t pde_t;

struct PageInfo {
    // Next page on the free list.
    // 空闲页面链表next指针
    struct PageInfo *pp_link;

    // pp_ref is the count of pointers (usually in page table entries)
    // to this page, for pages allocated using page_alloc.
    // Pages allocated at boot time using pmap.c&#39;s
    // boot_alloc do not have valid reference count fields.

    // 页面状态：空闲/占用
    // 多个不同的虚拟地址被同时映射到相同的物理页上,PageInfo结构体的pp_ref
    // 被位于虚拟地址UTOP之下的虚拟页所映射的次数
    uint16_t pp_ref;
};
</code></pre>
<p>下面通过mem_init函数有关<code>页面管理的代码进行简要的分析和流程的梳理</code>。部分代码如下</p>
<pre><code class="lang-C++">void mem_init(void)
{
    i386_detect_memory();

    // create initial page directory.
    // kern_pgdir指向操作系统的页目录表，这个页紧跟着操作系统内核之后
    kern_pgdir = (pde_t *) boot_alloc(PGSIZE);
    // 分配一个页的大小，并且将这部分内存清0
    memset(kern_pgdir, 0, PGSIZE);

    // 为页目录表添加第一个页目录表项
    // UVPT：0xef400000，从这个虚拟地址开始，存放的是操作系统的页表kern_pgdir
    // PADDR(kern_pgdir)计算kern_pgdir所对应的真实物理地址
    kern_pgdir[PDX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;

    // 分配一块内存，用来存放一个struct PageInfo的数组
    // 数组中的每一个PageInfo代表内存当中的一页,PageInfo为页面链表的节点
    pages = (struct PageInfo *) boot_alloc(sizeof(struct PageInfo) * npages);

    // 内存清0
    memset(pages, 0, npages * sizeof(struct PageInfo));

    page_init();

    check_page_free_list(1);
    check_page_alloc();
}
</code></pre>
<p>首先调用i386_detect_memory函数检测现在系统中有多少可用的内存空间。kern_pgdir是<code>指向操作系统的页目录表的指针</code>，操作系统之后工作在<code>虚拟内存模式下</code>时，就需要这个页目录表进行地址转换。<br><img src="/images/JOS/boot_alloc.png" alt=""></p>
<p>boot_alloc()函数<code>暂时当做页分配器</code>，之后我们使用的<code>真实页分配器是page_alloc()函数</code>。<code>而它的核心思想就是维护一个静态变量nextfree，里面存放着</code>下一个可以使用的空闲内存空间的虚拟地址`，所以每次当我们想要分配n个字节的内存时，我们都需要修改这个变量的值</p>
<p><code>为页目录表添加第一个页目录表项</code>后，分配一块内存，分配npages数目的结构体PageInfo空间，由<code>pages指向该块内存</code>。<code>操作系统内核通过这个数组来追踪所有内存页的使用情况</code>。然后运行函数page_init()，这个函数初始化两个信息：<code>pages数组和pages_free_list链表</code>(存放着所有空闲页的信息)</p>
<p>page_init后的内存分布<br><img src="/images/JOS/物理地址.png" alt=""></p>
<p>初始化所有物理内存页的相关数据结构后，<code>check_page_free_list(1)和check_page_alloc()</code>，这两个检查程序检查页面管理是否正确。前者检查page_free_list链表的<code>空闲页，是否都是合法/空闲</code>，后者检查<code>page_alloc()，page_free()两个函数是否能够正确运行</code></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://murfyexp.github.io/2017/02/27/操作系统/实模式-保护模式下的寻址/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shaojie Li">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://pic2.zhimg.com/85f345ee7c2ac6bf572a9a41895a4be5_200x112.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大傻与小火机写字的地方">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/27/操作系统/实模式-保护模式下的寻址/" itemprop="url">实模式/保护模式下的寻址</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-27T16:30:13-08:00">
                2017-02-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JOS操作系统/" itemprop="url" rel="index">
                    <span itemprop="name">JOS操作系统</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/02/27/操作系统/实模式-保护模式下的寻址/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/02/27/操作系统/实模式-保护模式下的寻址/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>8086处理器是一个16位的处理器，它的数据总线是16位，而地址总线是20位的，最多可以寻址1MB的地址空间。之后的80286处理器也是16位，但是地址总线有24位，从80286开始CPU演变出两种工作模式:实模式和保护模式</p>
<h3 id="x86寄存器"><a href="#x86寄存器" class="headerlink" title="x86寄存器"></a>x86寄存器</h3><p>在x86架构中，16位的处理器与32位处理器所对应的寄存器是有所不同的。8086寄存器组就分为<code>通用寄存器，专用寄存器和段寄存器三类总共15个</code>，其中通用寄存器有AX、BX、CX、DX、SP、BP、DI及 SI，<code>专用寄存器包括IP、SP 和FLAGS三个</code>16位寄存器， 而段寄存器则有CS、DS、SS、ES，这些寄存器都是 16位的</p>
<p><img src="/images/JOS/8086与80386寄存器对比表.png" alt="8086与80386寄存器对比表"></p>
<p>为支持1MB寻址空间，8086在实模式下引入了分段的方法。CPU中设置了<code>四个段寄存器:CS、DS、SS和 ES，分别用于可执行代码段 、数据段以及堆栈段</code> 。 每个段寄存器都是16位的，<code>对应于地址总线中的高16位</code>。</p>
<h3 id="段式内存管理"><a href="#段式内存管理" class="headerlink" title="段式内存管理"></a>段式内存管理</h3><p>段式内存管理带来了优势:</p>
<blockquote>
<ul>
<li>调试错误更容易定位</li>
<li>程序的地址不再需要采用内存物理地址进行编码</li>
<li>支持更大的内存地址</li>
</ul>
</blockquote>
<p>但是在该环境下，<code>应用程序可以直接对系统的任意内存地址(包括操作系统所在的区域)进行操作</code></p>
<p>保护模式，这种模式下内存段的访问受到了限制。<code>访问内存时不能直接从段寄存器中获得段的起始地址，而需要经过额外转换和检查</code>。在保护模式下，段范围不再受限于64K，可以达到16MB(或者80386的4GB)。</p>
<h4 id="实模式下段的管理"><a href="#实模式下段的管理" class="headerlink" title="实模式下段的管理"></a>实模式下段的管理</h4><p>实模式采用16位寻址模式，在该模式中，最大寻址空间为1MB，最大分段为64KB。</p>
<p>8086处理器地址总线扩展到20位，但算术逻辑运算单元(ALU)宽度即数据总线却只有16位，也就是说<code>直接参与运算的数值都是16位的</code>。寻址时，采用以下公式计算实际访问的物理内存地址:<code>实际物理地址 = (段寄存器 &lt;&lt; 4) + 偏移地址</code>这样，便实现了16位内存地址到20位物理地址的转换</p>
<p>80x86系列是<code>使用CS寄存器配合IP寄存器的组合来通知CPU指令在内存中的位置</code>。程序指令在执行过程中一般还需要有各种数据，<code>80x86系列有DS、ES、FS、GS、SS等用于指示不同用途的数据段在内存中的位置</code>。80x86系列使用中断机制来实现系统服务。总的来说，这些就是实模式一个程序运行所需的主要内容。</p>
<h4 id="保护模式下段的管理"><a href="#保护模式下段的管理" class="headerlink" title="保护模式下段的管理"></a>保护模式下段的管理</h4><p><code>保护模式下的分段机制</code><br>利用段选择子到全局描述符表中找到需要的段描述符，段描述符中就存放着真正的段的物理首地址，再加上偏移地址量便得到了最后的物理地址</p>
<p><img src="/images/JOS/保护模式段式寻址.jpg" alt="保护模式段式寻址"><br>一般保护模式段式寻址可用 xxxx:yyyyyyyy表示。其中xxxx表示索引，也就是 段选择子，是16位的;yyyyyyyy是偏移量，是32位的。</p>
<p>到哪里去寻找全局描述符表呢?80386以及以后的处理器专门设计了<code>一个寄存器GDTR</code>(Global Descriptor Table Register)，<code>专门用于存储全局描述符表在内</code>。GDTR寄存器有48位，其中有32位记录描述符表的物理地址，16位记录全局描述符表的长度(该表占据的物理内存字节数)<br><img src="/images/JOS/GDTR位分布图.jpg" alt="GDTR位分布图"></p>
<p>再来看看段描述符，段描述符实际上是一个占据64位内存(8个字节)的结构体<br><img src="/images/JOS/段描述符的结构.jpg" alt="段描述符的结构"></p>
<p>一个64位的<code>段描述符包含了段的物理首地址、段的界限以及段的属性</code>。在描述符中，段基址占32位，段限长占20位，属性占12位</p>
<h3 id="保护模式寻址实例"><a href="#保护模式寻址实例" class="headerlink" title="保护模式寻址实例"></a>保护模式寻址实例</h3><p>下面将通过一个例子来加深对保护模式寻址方式的理解。在这个程序开始执行的时候cs寄存器的值为0</p>
<pre><code class="lang-x86asm">.set PROT_MODE_CSEG， 0x8         # kernel code segment selector
.set PROT_MODE_DSEG， 0x10        # kernel data segment selector
.set CR0_PE_ON，      0x1         # protected mode enable flag
lgdt    gdtdesc

  movl    %cr0， %eax
  orl     $CR0_PE_ON， %eax
  movl    %eax， %cr0

  # Jump to next instruction， but in 32-bit code segment.
  # Switches processor into 32-bit mode.
  #  实模式跳转到保护模式
  ljmp    $PROT_MODE_CSEG， $protcseg

protcseg:
  movw    0x10， %ax
  movw    %ax，  %dx
  movl    0xf0000000， %ebx
  movl    0x20(%ebx)， %eax

gdt:                                    #gdt表的内容
  SEG_NULL                                # null seg
  SEG(STA_X|STA_R， 0x0， 0xffffffff)        # code seg
  SEG(STA_W， 0x0， 0xffffffff)            # data seg

gdtdesc:
  .word   0x17                            # sizeof(gdt) - 1
  .long   gdt
</code></pre>
<p>以上这一小段程序展示了<code>系统进入保护模式以及在保护模式中利用寄存器寻址的过程</code>。  </p>
<p>首先lgdt指令<code>将GDT表的地址和表长装入GDTR寄存器</code>，在gdtdesc标识的地方存有一个字及一个双字，前者为0x17表示表的长度(字节数)，后者是表的物理地址。</p>
<p>接着再将<code>CR0的保护模式开启位打开，系统便进入了保护模式</code>，开始采用保护模式的寻址模式进行地址的转换。这个时候，<code>内存中有GDT的3个表项</code>。</p>
<p>进入保护模式后系统立即执行了一个长跳转指令，<code>由于是在保护模式中，所以
PROT_MODE_CSEG被当作段选择子，而protcseg是偏移地址</code>。段选择子的值是0x8，于是对应的段描述符会是表中的第一项，即是<code>SEG(STA_X|STA_R， 0x0， 0xffffffff)</code>这一项，0x0表示段首地址是0，所以最终得到的物理地址为0 + protcseg，程序便会跳到 protcseg 所标识的位置来执行。</p>
<p>之后执行指令: <code>movl 0x20(%ebx)， %eax</code>， 如图所示可知段基址为0，于是物理地址是0+0x20+0xf000000=0xf000020，内存中这个位置的一个双字会被复制到eax寄存器中<br><img src="/images/JOS/保护模式寻址过程.jpg" alt="保护模式寻址过程"></p>
<p>这里能访问的到的0到4G的地址空间实际上是虚拟地址空间，在<code>开启分页机制后，还要经过页表转换才能得到真实地址</code>，而<code>在开启分页之前系统一般会控制只访问低地址</code>，这些问题到内存管理我们会进行更深入的讨论</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://murfyexp.github.io/2017/02/27/算法/Leetcode/8-5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shaojie Li">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://pic2.zhimg.com/85f345ee7c2ac6bf572a9a41895a4be5_200x112.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大傻与小火机写字的地方">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/27/算法/Leetcode/8-5/" itemprop="url">二叉树中累加和为指定值的最长路径</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-27T13:07:42-08:00">
                2017-02-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/面试算法/" itemprop="url" rel="index">
                    <span itemprop="name">面试算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/02/27/算法/Leetcode/8-5/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/02/27/算法/Leetcode/8-5/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><pre><code>给定一棵二叉树的头节点head和一个32位整数sum,二叉树节点值类型为整型，求累加和为sum的最长路径长度.  
路径是指从某个节点往下,每次最多选择一个孩子节点或者不选所形成的节点链
</code></pre>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/02/27/算法/Leetcode/8-5/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/8/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/10/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://pic2.zhimg.com/85f345ee7c2ac6bf572a9a41895a4be5_200x112.jpg"
                alt="Shaojie Li" />
            
              <p class="site-author-name" itemprop="name">Shaojie Li</p>
              <p class="site-description motion-element" itemprop="description">学习总结 思考感悟 知识管理</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">106</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Shaojie Li</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"murfyexp"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
  


















  





  

  

  

  
  

  

  

  

</body>
</html>
